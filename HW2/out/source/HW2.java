/* autogenerated by Processing revision 1293 on 2024-11-10 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.Random;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class HW2 extends PApplet {

Engine engine;

public void setup() {
    /* size commented out by preprocessor */;
    engine = new Engine();
}

public void draw() {
    background(255);
    engine.run();
}

// 當有滑鼠事件再重畫即可
public void mousePressed() {
  redraw();
}
public class Box {
    public Vector3 pos;
    public Vector3 size;
    protected int box_color = color(0);

    public Box(float x, float y, float w, float h) {
        pos = new Vector3(x, y, 0);
        size = new Vector3(w, h, 0);
    }

    public Box(Vector3 p, Vector3 s) {
        pos = p;
        size = s;
    }

    public Box setBoxColor(int c) {
        box_color = c;
        return this;
    }

    public void show() {
        fill(box_color);
        noStroke();
        rect(pos.x, pos.y, size.x, size.y);
    }

    public boolean checkInSide(Vector3 p) {
        if (p.x >= pos.x && p.x <= pos.x + size.x && p.y >= pos.y && p.y <= pos.y + size.y)
            return true;
        return false;
    }

    public boolean checkInSide() {
        if (mouseX >= pos.x && mouseX <= pos.x + size.x && mouseY >= pos.y && mouseY <= pos.y + size.y)
            return true;
        return false;
    }

}

public class Button extends Box {
    protected int click_color;
    protected boolean press = false;
    protected boolean once = false;
    protected PImage image = null;

    public Button(float x, float y, float w, float h) {
        super(x, y, w, h);
    }

    public Button(Vector3 p, Vector3 s) {
        super(p, s);
    }

    public Button setImage(PImage img) {
        image = img;
        return this;
    }

    public void run(ButtonFunction bf) {
        click(bf);
        show();
    }

    @Override
    public void show() {
        if (!press)
            fill(box_color);
        else
            fill(click_color);
        noStroke();
        rect(pos.x, pos.y, size.x, size.y);
        if (image != null)
            image(image, pos.x, pos.y, size.x, size.y);
    }

    public void setClickColor(int c) {
        click_color = c;
    }

    public Button setBoxAndClickColor(int c1, int c2) {
        setBoxColor(c1);
        setClickColor(c2);
        return this;
    }

    public void click(ButtonFunction bf) {

        if (!checkInSide())
            return;
        if (mousePressed) {
            press = true;
            if (!once) {
                bf.function();
                once = true;
            }
        } else {
            press = false;
            once = false;
        }
    }

}

public class HierarchyButton extends Button {
    String name;
    Shape shape;

    public HierarchyButton(float x, float y, float w, float h) {
        super(x, y, w, h);
    }

    public HierarchyButton(Vector3 p, Vector3 s) {
        super(p, s);
    }

    @Override
    public void show() {
        super.show();
        textAlign(CENTER, CENTER);
        textSize(15);
        fill(0);
        text(name, pos.x + 100, pos.y + 15);
    }
}

public class ShapeButton extends Button {
    private boolean selected = false;

    public ShapeButton(float x, float y, float w, float h) {
        super(x, y, w, h);
    }

    public ShapeButton(Vector3 p, Vector3 s) {
        super(p, s);
    }

    @Override
    public void show() {
        super.show();
        if (selected) {
            stroke(255, 0, 0);
            noFill();
            rect(pos.x - 2, pos.y - 2, size.x + 4, size.y + 4);
        }
    }

    public void beSelect() {
        setSelected(true);
    }

    public void setSelected(boolean b) {
        selected = b;
    }

    public Shape renderShape() {
        return null;
    }

}
@FunctionalInterface
interface ButtonFunction {
    void function();
}


static class Matrix4{
  float m[]=new float[16];
  Matrix4(){
    makeZero();
  }
  Matrix4(float b){
    Fill(b);
  }
  public void Fill(float b){
    for(int i=0;i<m.length;i+=1){
      m[i]=b;
    }
  }
  // rotate
  Matrix4(Vector3 a,Vector3 b,Vector3 c){
     m[0]  = a.x;  m[1]  = a.y;  m[2]  = a.z;    m[3]  = 0.0f;
     m[4]  = b.x;  m[5]  = b.y;  m[6]  = b.z;    m[7]  = 0.0f;
     m[8]  = c.x;  m[9]  = c.y;  m[10] = c.z;    m[11] = 0.0f;
     m[12] = 0.0f; m[13] = 0.0f; m[14] = 0.0f;   m[15] = 0.0f;
  }
  
  public void makeZero(){
    Fill(0);
  }
  public void makeIdentity(){
     m[0]  = 1.0f; m[1]  = 0.0f; m[2]  = 0.0f; m[3]  = 0.0f;
     m[4]  = 0.0f; m[5]  = 1.0f; m[6]  = 0.0f; m[7]  = 0.0f;
     m[8]  = 0.0f; m[9]  = 0.0f; m[10] = 1.0f; m[11] = 0.0f;
     m[12] = 0.0f; m[13] = 0.0f; m[14] = 0.0f; m[15] = 1.0f;
  }
  public void makeRotX(float a) {
    // TODO HW2
    // You need to implement the rotation of x-axis matrix here. (Roll)
    makeIdentity();
    Vector3 tmp = new Vector3(0, cos(a), sin(a));
    setYAxis(tmp);
    tmp = new Vector3(0, -sin(a), cos(a));
    setZAxis(tmp);
  }
  public void makeRotY(float a) {
    // TODO HW2
    // You need to implement the rotation of y-axis matrix here. (Pitch)
    makeIdentity();
    Vector3 tmp = new Vector3(cos(a), 0.0f, -sin(a));
    setXAxis(tmp);
    tmp = new Vector3(sin(a), 0.0f, cos(a));
    setZAxis(tmp);
  }
  public void makeRotZ(float a) {
     // TODO HW2
     // You need to implement the rotation of z-axis matrix here. (Yaw)
    makeIdentity();
    Vector3 tmp = new Vector3(cos(a), sin(a), 0.0f);
    setXAxis(tmp);
    tmp = new Vector3(-sin(a),cos(a), 0.0f);
    setYAxis(tmp);
  }
  
  public void makeTrans(Vector3 t) {
    // TODO HW2
    // You need to implement the translate matrix here.
    makeIdentity();
    setTranslation(t);
  }
  public void makeScale(Vector3 s) {
    // TODO HW2
    // You need to implement the scale matrix here.
    makeIdentity();
    setScale(s);
  }
  
  public void makeMirror(){
    m[0]  = -1;  m[1]  = 0.0f; m[2]  = 0.0f; m[3]  = 0.0f;
    m[4]  = 0.0f; m[5]  = -1;  m[6]  = 0.0f; m[7]  = 0.0f;
    m[8]  = 0.0f; m[9]  = 0.0f; m[10] = 1;  m[11] = 0.0f;
    m[12] = 0.0f; m[13] = 0.0f; m[14] = 0.0f; m[15] = 1.0f;
  }
  public static Matrix4 Zero(){
    Matrix4 matrix=new Matrix4();
    matrix.makeZero();
    return matrix;
  }
  
  public static Matrix4 Identity(){
    Matrix4 matrix=new Matrix4();
    matrix.makeIdentity();
    return matrix;
  }
  public static Matrix4 Mirror(){
    Matrix4 matrix=new Matrix4();
    matrix.makeMirror();
    return matrix;
  }
  public static Matrix4 RotX(float a){
    Matrix4 matrix=new Matrix4();
    matrix.makeRotX(a);
    return matrix;
  }
  
  public static Matrix4 RotY(float a){
    Matrix4 matrix=new Matrix4();
    matrix.makeRotY(a);
    return matrix;
  }
  
  public static Matrix4 RotZ(float a){
    Matrix4 matrix=new Matrix4();
    matrix.makeRotZ(a);
    return matrix;
  }
  
  public static Matrix4 Trans(Vector3 t){
    Matrix4 matrix=new Matrix4();
    matrix.makeTrans(t);
    return matrix;
  }
  
  public static Matrix4 Scale(Vector3 s){
    Matrix4 matrix=new Matrix4();
    matrix.makeScale(s);
    return matrix;
  }
  
  public static Matrix4 Scale(float s){
    Matrix4 matrix=new Matrix4();
    matrix.makeScale(new Vector3(s));
    return matrix;
  }
  
  //setter
  public Vector3 xAxis(){
    return new Vector3(m[0], m[4], m[8]);
  }
  public Vector3 yAxis(){
    return new Vector3(m[1], m[5], m[9]);
  }
  public Vector3 zAxis(){
    return new Vector3(m[2], m[6], m[10]);
  }
  public Vector3 translation(){
    return new Vector3(m[3], m[7], m[11]);
  }
  public Vector3 Scale(){
    return new Vector3(m[0], m[5], m[10]);
  }
  /*  translate matrix on homo space
      | 1 0 0 x |
      | 0 1 0 y |
      | 0 0 1 z |
      | 0 0 0 1 |
  */
  public void setTranslation(Vector3 t) {
    m[3] = t.x;
    m[7] = t.y;
    m[11] = t.z;
  }
  public void setXAxis(Vector3 t) {
    m[0] = t.x;
    m[4] = t.y;
    m[8] = t.z;
  }
  public void setYAxis(Vector3 t) {
    m[1] = t.x;
    m[5] = t.y;
    m[9] = t.z;
  }
  public void setZAxis(Vector3 t) {
    m[2] = t.x;
    m[6] = t.y;
    m[10] = t.z;
  }
  /*  scale matrix on homo space
      | x 0 0 0 |
      | 0 y 0 0 |
      | 0 0 z 0 |
      | 0 0 0 1 |
  */
  public void setScale(Vector3 s) {
    m[0] = s.x;
    m[5] = s.y;
    m[10] = s.z;
  }
  
  
  public Matrix4 transposed(){
    Matrix4 out=new Matrix4();
    out.m[0]  = m[0]; out.m[1]  = m[4]; out.m[2]  = m[8];  out.m[3]  = m[12];
    out.m[4]  = m[1]; out.m[5]  = m[5]; out.m[6]  = m[9];  out.m[7]  = m[13];
    out.m[8]  = m[2]; out.m[9]  = m[6]; out.m[10] = m[10]; out.m[11] = m[14];
    out.m[12] = m[3]; out.m[13] = m[7]; out.m[14] = m[11]; out.m[15] = m[15];
    return out;
  }
  
  public void Translate(Vector3 t) {
    m[3] += t.x;
    m[7] += t.y;
    m[11] += t.z;
  }
  public void stretch(Vector3 s) {
    m[0] *= s.x;
    m[5] *= s.y;
    m[10] *= s.z;
  }
  
  public Matrix4 add(Matrix4 b){
    Matrix4 out=new Matrix4();
    for(int i=0;i<m.length;i+=1){
      out.m[i]=m[i]+b.m[i];
    }
    return out;
  }
  public void plus(Matrix4 b){    
    for(int i=0;i<m.length;i+=1){
     m[i]+=b.m[i];
    }
  }
  
  public Matrix4 sub(Matrix4 b){
    Matrix4 out=new Matrix4();
    for(int i=0;i<m.length;i+=1){
      out.m[i]=m[i]-b.m[i];
    }
    return out;
  }
  public void minus(Matrix4 b){
    
    for(int i=0;i<m.length;i+=1){
     m[i]-=b.m[i];
    }
  }
  public Matrix4 mult(float b){
    Matrix4 out=new Matrix4();
    for(int i=0;i<m.length;i+=1){
      out.m[i]=m[i]*b;
    }
    return out;
  }
  
  public void times(float b){   
    for(int i=0;i<m.length;i+=1){
     m[i]*=b;
    }
  }  
  
  public Matrix4 div(float b){
    Matrix4 out=new Matrix4();
    for(int i=0;i<m.length;i+=1){
      out.m[i]=m[i]/b;
    }
    return out;
  }
  
  public void dive(float b){
    
    for(int i=0;i<m.length;i+=1){
     m[i]/=b;
    }
  }
  
  public Matrix4 mult(Matrix4 b){
    Matrix4 out=new Matrix4();
    out.m[0]  = b.m[0]*m[0]  + b.m[4]*m[1]  + b.m[8] *m[2]  + b.m[12]*m[3];
    out.m[1]  = b.m[1]*m[0]  + b.m[5]*m[1]  + b.m[9] *m[2]  + b.m[13]*m[3];
    out.m[2]  = b.m[2]*m[0]  + b.m[6]*m[1]  + b.m[10]*m[2]  + b.m[14]*m[3];
    out.m[3]  = b.m[3]*m[0]  + b.m[7]*m[1]  + b.m[11]*m[2]  + b.m[15]*m[3];

    out.m[4]  = b.m[0]*m[4]  + b.m[4]*m[5]  + b.m[8] *m[6]  + b.m[12]*m[7];
    out.m[5]  = b.m[1]*m[4]  + b.m[5]*m[5]  + b.m[9] *m[6]  + b.m[13]*m[7];
    out.m[6]  = b.m[2]*m[4]  + b.m[6]*m[5]  + b.m[10]*m[6]  + b.m[14]*m[7];
    out.m[7]  = b.m[3]*m[4]  + b.m[7]*m[5]  + b.m[11]*m[6]  + b.m[15]*m[7];

    out.m[8]  = b.m[0]*m[8]  + b.m[4]*m[9]  + b.m[8] *m[10] + b.m[12]*m[11];
    out.m[9]  = b.m[1]*m[8]  + b.m[5]*m[9]  + b.m[9] *m[10] + b.m[13]*m[11];
    out.m[10] = b.m[2]*m[8]  + b.m[6]*m[9]  + b.m[10]*m[10] + b.m[14]*m[11];
    out.m[11] = b.m[3]*m[8]  + b.m[7]*m[9]  + b.m[11]*m[10] + b.m[15]*m[11];

    out.m[12] = b.m[0]*m[12] + b.m[4]*m[13] + b.m[8] *m[14] + b.m[12]*m[15];
    out.m[13] = b.m[1]*m[12] + b.m[5]*m[13] + b.m[9] *m[14] + b.m[13]*m[15];
    out.m[14] = b.m[2]*m[12] + b.m[6]*m[13] + b.m[10]*m[14] + b.m[14]*m[15];
    out.m[15] = b.m[3]*m[12] + b.m[7]*m[13] + b.m[11]*m[14] + b.m[15]*m[15];
    return out;
  }
  
  public void times(Matrix4 b){
    m=this.mult(b).m;  
  }
  
  public Vector4 mult(Vector4 b){
    return new Vector4(
      m[0]*b.x  + m[1]*b.y  + m[2]*b.z  + m[3]*b.w,
      m[4]*b.x  + m[5]*b.y  + m[6]*b.z  + m[7]*b.w,
      m[8]*b.x  + m[9]*b.y  + m[10]*b.z + m[11]*b.w,
      m[12]*b.x + m[13]*b.y + m[14]*b.z + m[15]*b.w
    );
  }
  public Vector3 MulPoint(Vector3 b){
    Vector3 p=new Vector3(
      m[0] * b.x + m[1] * b.y + m[2] * b.z + m[3],
      m[4] * b.x + m[5] * b.y + m[6] * b.z + m[7],
      m[8] * b.x + m[9] * b.y + m[10] * b.z + m[11]
    );
    float w = m[12] * b.x + m[13] * b.y + m[14] * b.z + m[15];
    return p.dive(w);
  }
  public Vector3 MulDirection(Vector3 b){
    return new Vector3(
      m[0] * b.x + m[1] * b.y + m[2] * b.z,
      m[4] * b.x + m[5] * b.y + m[6] * b.z,
      m[8] * b.x + m[9] * b.y + m[10] * b.z
    );
  }
  public Matrix4 Inverse(){
    Matrix4 inv=new Matrix4();
    inv.m[0] = m[5] * m[10] * m[15] -
      m[5] * m[11] * m[14] -
      m[9] * m[6] * m[15] +
      m[9] * m[7] * m[14] +
      m[13] * m[6] * m[11] -
      m[13] * m[7] * m[10];

    inv.m[4] = -m[4] * m[10] * m[15] +
      m[4] * m[11] * m[14] +
      m[8] * m[6] * m[15] -
      m[8] * m[7] * m[14] -
      m[12] * m[6] * m[11] +
      m[12] * m[7] * m[10];

    inv.m[8] = m[4] * m[9] * m[15] -
      m[4] * m[11] * m[13] -
      m[8] * m[5] * m[15] +
      m[8] * m[7] * m[13] +
      m[12] * m[5] * m[11] -
      m[12] * m[7] * m[9];

    inv.m[12] = -m[4] * m[9] * m[14] +
      m[4] * m[10] * m[13] +
      m[8] * m[5] * m[14] -
      m[8] * m[6] * m[13] -
      m[12] * m[5] * m[10] +
      m[12] * m[6] * m[9];

    inv.m[1] = -m[1] * m[10] * m[15] +
      m[1] * m[11] * m[14] +
      m[9] * m[2] * m[15] -
      m[9] * m[3] * m[14] -
      m[13] * m[2] * m[11] +
      m[13] * m[3] * m[10];

    inv.m[5] = m[0] * m[10] * m[15] -
      m[0] * m[11] * m[14] -
      m[8] * m[2] * m[15] +
      m[8] * m[3] * m[14] +
      m[12] * m[2] * m[11] -
      m[12] * m[3] * m[10];

    inv.m[9] = -m[0] * m[9] * m[15] +
      m[0] * m[11] * m[13] +
      m[8] * m[1] * m[15] -
      m[8] * m[3] * m[13] -
      m[12] * m[1] * m[11] +
      m[12] * m[3] * m[9];

    inv.m[13] = m[0] * m[9] * m[14] -
      m[0] * m[10] * m[13] -
      m[8] * m[1] * m[14] +
      m[8] * m[2] * m[13] +
      m[12] * m[1] * m[10] -
      m[12] * m[2] * m[9];

    inv.m[2] = m[1] * m[6] * m[15] -
      m[1] * m[7] * m[14] -
      m[5] * m[2] * m[15] +
      m[5] * m[3] * m[14] +
      m[13] * m[2] * m[7] -
      m[13] * m[3] * m[6];

    inv.m[6] = -m[0] * m[6] * m[15] +
      m[0] * m[7] * m[14] +
      m[4] * m[2] * m[15] -
      m[4] * m[3] * m[14] -
      m[12] * m[2] * m[7] +
      m[12] * m[3] * m[6];

    inv.m[10] = m[0] * m[5] * m[15] -
      m[0] * m[7] * m[13] -
      m[4] * m[1] * m[15] +
      m[4] * m[3] * m[13] +
      m[12] * m[1] * m[7] -
      m[12] * m[3] * m[5];

    inv.m[14] = -m[0] * m[5] * m[14] +
      m[0] * m[6] * m[13] +
      m[4] * m[1] * m[14] -
      m[4] * m[2] * m[13] -
      m[12] * m[1] * m[6] +
      m[12] * m[2] * m[5];

    inv.m[3] = -m[1] * m[6] * m[11] +
      m[1] * m[7] * m[10] +
      m[5] * m[2] * m[11] -
      m[5] * m[3] * m[10] -
      m[9] * m[2] * m[7] +
      m[9] * m[3] * m[6];

    inv.m[7] = m[0] * m[6] * m[11] -
      m[0] * m[7] * m[10] -
      m[4] * m[2] * m[11] +
      m[4] * m[3] * m[10] +
      m[8] * m[2] * m[7] -
      m[8] * m[3] * m[6];

    inv.m[11] = -m[0] * m[5] * m[11] +
      m[0] * m[7] * m[9] +
      m[4] * m[1] * m[11] -
      m[4] * m[3] * m[9] -
      m[8] * m[1] * m[7] +
      m[8] * m[3] * m[5];

    inv.m[15] = m[0] * m[5] * m[10] -
      m[0] * m[6] * m[9] -
      m[4] * m[1] * m[10] +
      m[4] * m[2] * m[9] +
      m[8] * m[1] * m[6] -
      m[8] * m[2] * m[5];

    float det = m[0] * inv.m[0] + m[1] * inv.m[4] + m[2] * inv.m[8] + m[3] * inv.m[12];
    inv.dive(det);
    return inv;
  }
  public String toString(){
    return str(m[0])+" "+str(m[1])+" "+str(m[2])+" "+str(m[3])+"\n"
          +str(m[4])+" "+str(m[5])+" "+str(m[6])+" "+str(m[7])+"\n"
          +str(m[8])+" "+str(m[9])+" "+str(m[10])+" "+str(m[11])+"\n"
          +str(m[12])+" "+str(m[13])+" "+str(m[14])+" "+str(m[15]);
  }
}

public class Shape{   
    Vector3[] vertex = new Vector3[0];
    Transform transform = new Transform();
    boolean resistance = false;
    public void drawShape(){                      
        Matrix4 model_matrix = localToWorld();
        // println(model_matrix.toString() +                                                  "\n");
        Vector3[] t_pos = new Vector3[vertex.length];
        for(int i=0;i<t_pos.length;i++){
            // 照理來說應該要取homogeneous的?
            t_pos[i] = model_matrix.mult(vertex[i].getVector4()).homogenized();   
            // t_pos[i] = model_matrix.mult(vertex[i].getVector4()).xyz();    
        }
        t_pos = Sutherland_Hodgman_algorithm(t_pos,engine.boundary);
        Vector3[] ssaa_pos = new Vector3[t_pos.length];
        for(int i=0;i<t_pos.length;i++){
            ssaa_pos[i] = new Vector3(map(t_pos[i].x,-1,1,40,1040),map(t_pos[i].y,-1,1,100,2 * (height-50)),0);
            t_pos[i] = new Vector3(map(t_pos[i].x,-1,1,20,520),map(t_pos[i].y,-1,1,50,height-50),0);
        }

        Vector3[] minmax = findBoundBox(t_pos);
        
        loadPixels();       
        for(int i = PApplet.parseInt(minmax[0].x);i<=minmax[1].x;i++){
            for(int j = PApplet.parseInt(minmax[0].y);j<=minmax[1].y;j++){
                if(resistance){
                    int cnt = 0;
                    if(pnpoly(i * 2, j * 2, ssaa_pos)){
                        ++cnt;
                    }      
                    if(pnpoly(i * 2 + 1, j * 2, ssaa_pos)){
                        ++cnt;
                    }  
                    if(pnpoly(i * 2, j * 2 + 1, ssaa_pos)){
                        ++cnt;
                    }  
                    if(pnpoly(i * 2 + 1, j * 2 + 1, ssaa_pos)){
                        ++cnt;
                    }
                    if(cnt != 0){
                        int c = 100 * cnt / 4;      
                        drawPoint(i, j, color(255 - c, 255 - c, 255 - c, c));
                    }
                }
                else if(pnpoly(i, j, t_pos)){
                    drawPoint(i, j, color(255 - 100));
                }
            }
        }
        
             
        // for(int i=0;i<t_pos.length;i++){          
        //     CGLine(t_pos[i].x,t_pos[i].y,t_pos[(i+1)%t_pos.length].x,t_pos[(i+1)%t_pos.length].y); // if you finish it, you can commant this sentance
        // }

        // 以pixel將畫面畫上
        updatePixels();
        
    };
    
    public Matrix4 localToWorld(){
        return Matrix4.Trans(transform.position).mult(Matrix4.RotZ(transform.rotation.z)).mult(Matrix4.Scale(transform.scale));
    }
    
    public String getShapeName(){
        return "";
    }
    
}

public class Rectangle extends Shape{
    
    public Rectangle(){
        vertex = new Vector3[]{new Vector3(-0.1f,-0.1f,0),new Vector3(-0.1f,0.1f,0),new Vector3(0.1f,0.1f,0),new Vector3(0.1f,-0.1f,0)};    
    }
    @Override
    public String getShapeName(){
        return "Rectangle";
    }
    
}

public class Star extends Shape{
    
    public Star(){
        vertex = new Vector3[]{new Vector3(0.1f,0,0),new Vector3(0.0309f,0.02244f,0),
                               new Vector3(0.0309f,0.0951f,0),new Vector3(-0.01195f,0.03637f,0),
                               new Vector3(-0.0809f,0.05877f,0),new Vector3(-0.03834f,0.0002f,0),
                               new Vector3(-0.0809f,-0.05811f,0),new Vector3(-0.012f,-0.03599f,0),
                               new Vector3(0.0309f,-0.0951f,0),new Vector3(0.0309f,-0.02219f,0)};    

    }
    @Override
    public String getShapeName(){
        return "Star";
    }
    
   
}

public class Line extends Shape{
    Vector3 point1;
    Vector3 point2;
    
    public Line(){};
    public Line(Vector3 v1,Vector3 v2){
        point1 = v1;
        point2 = v2;
    }
    
    @Override
    public void drawShape(){
        CGLine(point1.x,point1.y,point2.x,point2.y);
    }
}



public class Polygon extends Shape{
    ArrayList<Vector3> verties = new ArrayList<Vector3>();
     public Polygon(ArrayList<Vector3> v){
        verties= v;
    }
    
    @Override
    public void drawShape(){
        if(verties.size()<=0) return;
        for(int i=0;i<=verties.size();i++){
              Vector3 p1 = verties.get(i%verties.size());
              Vector3 p2 = verties.get((i+1)%verties.size());
              CGLine(p1.x,p1.y,p2.x,p2.y);
         }
    } 
}
public class ShapeRenderer {
    private Box box;
    private ArrayList<Shape> shapes;

    public ShapeRenderer() {
        box = new Box(20, 50, 500, height - 100);
        box.setBoxColor(250);
        shapes = new ArrayList<Shape>();
    }

    public void run() {
        box.show();
        shapes.forEach(Shape::drawShape);
    }

    public void addShape(Shape s) {
        shapes.add(s);
        engine.hierarchy.addButton(s);
    }

    public boolean checkInBox(Vector3 v) {
        return box.checkInSide(v);
    }

    public void popShape() {
        if (shapes.size() <= 0)
            return;
        shapes.remove(shapes.size() - 1);
    }

    public void clear() {
        shapes.clear();
    }
}

public class Hierarchy {
    private Box box;
    ArrayList<Shape> shapes;
    ArrayList<HierarchyButton> buttons;

    public Hierarchy(ArrayList<Shape> s) {
        box = new Box(500 + 40, 50, 200, height - 100);
        box.setBoxColor(250);
        shapes = s;
        buttons = new ArrayList<HierarchyButton>();
    }

    public void addButton(Shape s) {
        float y = buttons.size() * 30;
        HierarchyButton hb = new HierarchyButton(box.pos.x, box.pos.y + y, 200, 30);
        hb.name = s.getShapeName();
        hb.setBoxAndClickColor(color(250), color(150));
        hb.shape = s;
        buttons.add(hb);
    }

    public void run() {
        textAlign(LEFT, CENTER);
        textSize(18);
        fill(0);
        text("Hierarchy", box.pos.x, box.pos.y - 10);
        box.show();

        for (HierarchyButton hb : buttons) {
            hb.run(() -> {
                engine.inspector.setShape(hb.shape);
            });
        }
    }
}
public class Inspector {
    private Box box;
    Shape shape;
    Slider[] position_slider = new Slider[3];
    Slider[] rotation_slider = new Slider[3];
    Slider[] scale_slider = new Slider[3];
    String inspectName = "xyz";
    // 新增勾選框，用來選擇是否啟用抗拒尺
    Checkbox resistanceCheckbox;

    public Inspector() {
        box = new Box(740 + 20, 50, 200, height - 100);
        box.setBoxColor(250);
    }

    public void setShape(Shape s) {
        shape = s;
        for (int i = 0; i < position_slider.length; i++) {
            position_slider[i] = new Slider(box.pos.add(new Vector3(40, 30 + i * 20, 0)),
                    new Vector3(box.pos.x + 40, box.pos.x + 150, 0), new Vector3(-1, 1, 0), true);
        }
        resistanceCheckbox = new Checkbox(box.pos.add(new Vector3(10, 30 + 270, 0)),
                             20, 20, "SSAA");
        position_slider[0].setValue(shape.transform.position.x);
        position_slider[1].setValue(shape.transform.position.y);
        position_slider[2].setValue(shape.transform.position.z);

        for (int i = 0; i < rotation_slider.length; i++) {
            rotation_slider[i] = new Slider(box.pos.add(new Vector3(40, 30 + i * 20 + 100, 0)),
                    new Vector3(box.pos.x + 40, box.pos.x + 150, 0), new Vector3(0, 6.28f, 0), true);
        }
        rotation_slider[0].setValue(shape.transform.rotation.x);
        rotation_slider[1].setValue(shape.transform.rotation.y);
        rotation_slider[2].setValue(shape.transform.rotation.z);

        for (int i = 0; i < scale_slider.length; i++) {
            scale_slider[i] = new Slider(box.pos.add(new Vector3(40, 30 + i * 20 + 200, 0)),
                    new Vector3(box.pos.x + 40, box.pos.x + 150, 0), new Vector3(0.1f, 3, 0), true);
        }
        scale_slider[0].setValue(shape.transform.scale.x);
        scale_slider[1].setValue(shape.transform.scale.y);
        scale_slider[2].setValue(shape.transform.scale.z);
    }

    public void run() {
        textAlign(LEFT, CENTER);
        textSize(18);
        fill(0);
        text("Inspector", box.pos.x, box.pos.y - 10);
        box.show();
        if (shape != null) {
            textAlign(LEFT, CENTER);
            textSize(15);
            fill(0);
            text("position", box.pos.x, box.pos.y + 15);
            for (int i = 0; i < position_slider.length; i++) {
                textAlign(LEFT, CENTER);
                textSize(15);
                fill(0);
                text(inspectName.charAt(i), box.pos.x, position_slider[i].pos.y + 5);
                text(position_slider[i].value(), box.pos.x + 170, position_slider[i].pos.y + 5);
                position_slider[i].show();
                position_slider[i].click();
            }
            shape.transform.position = new Vector3(position_slider[0].value(), position_slider[1].value(),
                    position_slider[2].value());

            textAlign(LEFT, CENTER);
            textSize(15);
            fill(0);
            text("rotation", box.pos.x, box.pos.y + 15 + 100);
            for (int i = 0; i < rotation_slider.length; i++) {
                textAlign(LEFT, CENTER);
                textSize(15);
                fill(0);
                text(inspectName.charAt(i), box.pos.x, rotation_slider[i].pos.y + 5);
                text(rotation_slider[i].value(), box.pos.x + 170, rotation_slider[i].pos.y + 5);
                rotation_slider[i].show();
                rotation_slider[i].click();
            }
            shape.transform.rotation = new Vector3(rotation_slider[0].value(), rotation_slider[1].value(),
                    rotation_slider[2].value());

            textAlign(LEFT, CENTER);
            textSize(15);
            fill(0);
            text("scale", box.pos.x, box.pos.y + 15 + 200);
            for (int i = 0; i < scale_slider.length; i++) {
                textAlign(LEFT, CENTER);
                textSize(15);
                fill(0);
                text(inspectName.charAt(i), box.pos.x, scale_slider[i].pos.y + 5);
                text(scale_slider[i].value(), box.pos.x + 170, scale_slider[i].pos.y + 5);
                scale_slider[i].show();
                scale_slider[i].click();
            }
            shape.transform.scale = new Vector3(scale_slider[0].value(), scale_slider[1].value(),
                    scale_slider[2].value());
            shape.resistance = resistanceCheckbox.isChecked();
            // 顯示和處理抗拒尺勾選框
            resistanceCheckbox.show();
            resistanceCheckbox.click();
        }
    }
}

public class Transform {
    Vector3 position;
    Vector3 rotation;
    Vector3 scale;
    Random random = new Random();

    public Transform() {
        float randomFloat;

        position = new Vector3();

        rotation = new Vector3();

        scale = new Vector3(1, 1, 1);
    }

    public Transform(Vector3 pos, Vector3 rot, Vector3 scl) {
        position = pos;
        rotation = rot;
        scale = scl;
    }
}
static final public class Vector3 {
    private float x;
    private float y;
    private float z;

    Vector3() {
        x=0;
        y=0;
        z=0;
    }
    Vector3(float _a) {
        x=_a;
        y=_a;
        z=_a;
    }
    Vector3(float _x, float _y, float _z) {
        x=_x;
        y=_y;
        z=_z;
    }
    public float x() {
        return x;
    }
    public float y() {
        return y;
    }
    public float z() {
        return z;
    }

    public float xyz(int i) {
        if (i==0) return x;
        else if (i==1) return y;
        else return z;
    }
    public static Vector3 Zero() {
        return new Vector3(0);
    }
    public static Vector3 Ones() {
        return new Vector3(1);
    }
    public static Vector3 UnitX() {
        return new Vector3(1, 0, 0);
    }
    public static Vector3 UnitY() {
        return new Vector3(0, 1, 0);
    }
    public static Vector3 UnitZ() {
        return new Vector3(0, 0, 1);
    }

    public void set(float _x, float _y, float _z) {
        x = _x;
        y = _y;
        z = _z;
    }
    public void setZero() {
        x = 0.0f;
        y = 0.0f;
        z = 0.0f;
    }
    public void setOnes() {
        x = 1.0f;
        y = 1.0f;
        z = 1.0f;
    }
    public void setUnitX() {
        x = 1.0f;
        y = 0.0f;
        z = 0.0f;
    }
    public void setUnitY() {
        x = 0.0f;
        y = 1.0f;
        z = 0.0f;
    }
    public void setUnitZ() {
        x = 0.0f;
        y = 0.0f;
        z = 1.0f;
    }


    public static Vector3 add(Vector3 a, Vector3 b) {
        Vector3 result=new Vector3();
        result.x=a.x+b.x;
        result.y=a.y+b.y;
        result.z=a.z+b.z;
        return result;
    }
    public static Vector3 sub(Vector3 a, Vector3 b) {
        Vector3 result=new Vector3();
        result.x=a.x-b.x;
        result.y=a.y-b.y;
        result.z=a.z-b.z;
        return result;
    }
    public static Vector3 mult(float n, Vector3 a) {
        Vector3 result=new Vector3();
        result.x=n*a.x;
        result.y=n*a.y;
        result.z=n*a.z;
        return result;
    }
    public Vector3 mult(float n) {
        Vector3 result=new Vector3();
        result.x=n*x;
        result.y=n*y;
        result.z=n*z;
        return result;
    }


    public void product(float n) {

        x*=n;
        y*=n;
        z*=n;
    }

    public Vector3 dive(float n) {
        Vector3 result=new Vector3();
        result.x=x/n;
        result.y=y/n;
        result.z=z/n;
        return result;
    }
    public float minComponent(){
        return min(x,min(y,z));
    }
    
    public float maxComponent(){
        return max(x,max(y,z));
    }
    
    public static Vector3 cross(Vector3 a, Vector3 b) {
        Vector3 result=new Vector3();
        result.x=a.y*b.z-a.z*b.y;
        result.y=a.z*b.x-a.x*b.z;
        result.z=a.x*b.y-a.y*b.x;
        return result;
    }

    public static float dot(Vector3 a, Vector3 b) {
        return a.x*b.x+a.y*b.y+a.z*b.z;
    }
    public float norm() {
        return sqrt(x*x+y*y+z*z);
    }

    public void print() {
        println("x: "+x+" y: "+y+" z: "+z);
    }
    public Vector3 unit_vector() {
        return Vector3.mult(1/this.norm(), this);
    }
    public void normalize() {
        float a=1/this.norm();
        this.product(a);
    }

    public static Vector3 unit_vector(Vector3 v) {
        return Vector3.mult(1/v.norm(), v);
    }
    public Vector3 sub(Vector3 b) {
        Vector3 result=new Vector3();
        result.x=x-b.x;
        result.y=y-b.y;
        result.z=z-b.z;
        return result;
    }
    public Vector3 add(Vector3 b) {
        Vector3 result=new Vector3();
        result.x=x+b.x;
        result.y=y+b.y;
        result.z=z+b.z;
        return result;
    }

    public void minus(Vector3 b) {

        x-=b.x;
        y-=b.y;
        z-=b.z;
    }
    public void plus(Vector3 b) {

        x+=b.x;
        y+=b.y;
        z+=b.z;
    }

    public float length_squared() {
        return x*x+y*y+z*z;
    }
    public float length() {
        return sqrt(this.length_squared());
    }

    public boolean near_zero() {
        float s=1e-8f;
        return (abs(x)<s)&&abs(y)<s&&abs(z)<s;
    }
    public Vector3 product(Vector3 v) {
        Vector3 result=new Vector3();
        result.x=x*v.x;
        result.y=y*v.y;
        result.z=z*v.z;
        return result;
    }



    public Vector3 inv() {
        return new Vector3(1/x, 1/y, 1/z);
    }
    public float magSq() {
        return x*x+y*y+z*z;
    }
    public void clipMag(float m) {
        float r=magSq()/(m*m);
        if (r>1) {
            float sr=sqrt(r);
            x/=sr;
            y/=sr;
            z/=sr;
        }
    }

    public Vector3 copy() {
        return new Vector3(x, y, z);
    }
    
    public void copy(Vector3 b) {
        x=b.x;
        y=b.y;
        z=b.z;
    }
     public Vector4 getVector4() {
        return new Vector4(this, 1);
    }
    public Vector4 getVector4(float b) {
        return new Vector4(this, b);
    }

    @Override
        public String toString() {
        return "x : "+x+" y : "+y+" z : "+z;
    }
}


static public class Vector4 {
    float x, y, z, w;
    Vector4() {
    }
    Vector4(Vector3 xyz, float w) {
        this.x=xyz.x;
        this.y=xyz.y;
        this.z=xyz.z;
        this.w=w;
    }
    Vector4(float x, float y, float z, float w) {
        this.x=x;
        this.y=y;
        this.z=z;
        this.w=w;
    }
    Vector4(float x) {
        this.x=x;
        this.y=x;
        this.z=x;
        this.w=x;
    }

    public Vector3 xyz() {
        return new Vector3(x, y, z);
    }
    public Vector3 xyzNormalize() {
        return xyz().unit_vector();
    }
    public Vector3 homogenized() {
        //if (w<0) return new Vector3(-x/w, -y/w, -z/w);
        return new Vector3(x/w, y/w, z/w);
    }

    public Vector4 reverseW() {
        return new Vector4(x, y, z, -abs(w));
    }

    public Vector4 add(Vector4 v) {
        return new Vector4(x+v.x, y+v.y, z+v.z, w);
    }

    public Vector4 mult(float b) {
        return new Vector4(x*b, y*b, z*b, w);
    }
    public Vector4 mult(Matrix4 m) {
        return new Vector4(
            m.m[0]*x  + m.m[1]*y  + m.m[2]*z  + m.m[3]*w,
            m.m[4]*x  + m.m[5]*y  + m.m[6]*z  + m.m[7]*w,
            m.m[8]*x  + m.m[9]*y  + m.m[10]*z + m.m[11]*w,
            m.m[12]*x + m.m[13]*y + m.m[14]*z + m.m[15]*w
            );
    }

    public void multiply(float b) {
        x*=b;
        y*=b;
        z*=b;
    }


    public Vector4 div(float b) {
        return new Vector4(x/b, y/b, z/b, w);
    }
    public void dive(float b) {
        x/=b;
        y/=b;
        z/=b;
        w/=b;
    }
    public float dot(Vector4 b) {
        return x*b.x + y*b.y + z*b.z;
    }

    public float dot(Vector3 b) {
        return x*b.x + y*b.y + z*b.z;
    }

    @Override
        public String toString() {
        return "x : "+x+" y : "+y+" z : "+z + " w : " + w;
    }
}
public class Checkbox {
    private Vector3 pos;
    private float width, height;
    private boolean isChecked;
    private boolean isClicked; // 用來避免多次觸發
    private String label;

    public Checkbox(Vector3 pos, float width, float height, String label) {
        this.pos = pos;
        this.width = width;
        this.height = height;
        this.label = label;
        this.isChecked = false;
        this.isClicked = false;
    }

    public void show() {
        fill(!isClicked ? color(100) : color(255));
        rect(pos.x, pos.y, width, height);  // 顯示勾選框

        // 如果已勾選，顯示勾選標誌
        if (isChecked) {
            stroke(100, 0, 0);
            line(pos.x, pos.y + height / 2, pos.x + width / 3, pos.y + height);
            line(pos.x + width / 3, pos.y + height, pos.x + width, pos.y);
        }

        // 顯示文字標籤
        textSize(15);
        fill(0);
        text(label, pos.x + width + 10, pos.y + height / 2);
    }

    public void click() {
        if (mousePressed) {
            if (!isClicked && mouseOver()) {
                isChecked = !isChecked;
                isClicked = true; // 設置已點擊狀態
            }
        } else {
            isClicked = false; // 當鼠標釋放時重置點擊狀態
        }
    }

    public boolean isChecked() {
        return isChecked;
    }

    private boolean mouseOver() {
        return mouseX >= pos.x && mouseX <= pos.x + width &&
               mouseY >= pos.y && mouseY <= pos.y + height;
    }
}
public class Engine {
    ShapeRenderer shapeRenderer;
    Inspector inspector;
    Hierarchy hierarchy;

    Vector3[] boundary = { new Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0), new Vector3(1, -1, 0) };

    ArrayList<ShapeButton> shapeButton = new ArrayList<ShapeButton>();
    ShapeButton rectangleButton;
    ShapeButton starButton;

    public Engine() {
        shapeRenderer = new ShapeRenderer();
        inspector = new Inspector();
        hierarchy = new Hierarchy(shapeRenderer.shapes);

        initButton();
    }

    public void initButton() {
        rectangleButton = new ShapeButton(20, 10, 30, 30) {
            @Override
            public void show() {
                super.show();
                stroke(0);
                line(pos.x + 2, pos.y + 2, pos.x + size.x - 2, pos.y + 2);
                line(pos.x + 2, pos.y + size.y - 2, pos.x + size.x - 2, pos.y + size.y - 2);
                line(pos.x + size.x - 2, pos.y + 2, pos.x + size.x - 2, pos.y + size.y - 2);
                line(pos.x + 2, pos.y + 2, pos.x + 2, pos.y + size.y - 2);
            }

            @Override
            public Shape renderShape() {
                return new Rectangle();
            }
        };

        rectangleButton.setBoxAndClickColor(color(250), color(150));
        shapeButton.add(rectangleButton);

        starButton = new ShapeButton(60, 10, 30, 30) {
            @Override
            public void show() {
                super.show();
            }

            @Override
            public Shape renderShape() {
                return new Star();
            }
        };

        starButton.setImage(loadImage("star.png"));
        starButton.setBoxAndClickColor(color(250), color(150));
        shapeButton.add(starButton);
    }

    public void run() {
        shapeRenderer.run();
        hierarchy.run();
        inspector.run();
        for (ShapeButton sb : shapeButton) {
            sb.run(() -> {
                shapeRenderer.addShape(sb.renderShape());
            });
        }
    }

}
class Slider extends Button {
    boolean vertical = false;
    Vector3 start_end_point;
    Vector3 min_max_value;

    Slider(Vector3 p, Vector3 sep, Vector3 mmv, boolean v) {
        super(p, null);
        vertical = v;
        Vector3 s = vertical ? new Vector3(20, 10, 0) : new Vector3(10, 20, 0);
        start_end_point = sep;
        min_max_value = mmv;
        size = s;
        setBoxAndClickColor(color(100), color(70));
    }

    @Override
    public void show() {
        if (vertical) {
            fill(150);
            rect(start_end_point.x, pos.y, start_end_point.y - start_end_point.x, 10);
        } else {
            fill(150);
            rect(pos.x, start_end_point.x, 10, start_end_point.y - start_end_point.x);
        }
        super.show();

    }

    public void click() {

        if (!checkInSide() && !press)
            return;
        if (mousePressed) {
            press = true;
            if (vertical)
                pos = new Vector3(max(start_end_point.x, min(start_end_point.y, mouseX)), pos.y, 0);
            else
                pos = new Vector3(pos.x, max(start_end_point.x, min(start_end_point.y, mouseY)), 0);
        } else {
            press = false;
            once = false;
        }
    }

    public float value() {
        return map(vertical ? pos.x : pos.y, start_end_point.x, start_end_point.y, min_max_value.x, min_max_value.y);
    }

    public void setValue(float v) {
        if (vertical) {
            pos.x = map(v, min_max_value.x, min_max_value.y, start_end_point.x, start_end_point.y);
        } else {
            pos.y = map(v, min_max_value.x, min_max_value.y, start_end_point.x, start_end_point.y);
        }
    }

}
public void CGLine(float x1, float y1, float x2, float y2) {
    // TODO HW1
    // Please paste your code from HW1 CGLine.
    // f() = a*x + b*y + c = 0

    // float -> int -> float, avoid finite loop
    x1 = floor(x1); x2 = floor(x2);
    y1 = floor(y1); y2 = floor(y2);
    float a = Math.abs(y2 - y1);
    float b = Math.abs(x2 - x1);
    // next step
    float sx = (x1 > x2? -1 : 1);
    float sy = (y1 > y2? -1 : 1);
    // check slope dir
    float m = a / b;  
    float d = (m > 1? b - 0.5f * a : a - 0.5f * b); 
    while(true){
        drawPoint(x1, y1, color(0, 0, 0));
        if(m > 1 && y1 != y2){
            if(d > 0){
                d -= a;
                x1 += sx;
            }
            d += b;
            y1 += sy;
        }
        else if(m <= 1 && x1 != x2){
            if(d > 0){
                d -= b;
                y1 += sy;
            }
            d += a;
            x1 += sx;
        }
        else break;
    }
}

public boolean outOfBoundary(float x, float y) {
    if (x < 0 || x >= width || y < 0 || y >= height)
        return true;
    return false;
}

public void drawPoint(float x, float y, int c) {
    int index = (int) y * width + (int) x;
    if (outOfBoundary(x, y))
        return;
    pixels[index] = c;
}

public float distance(Vector3 a, Vector3 b) {
    Vector3 c = a.sub(b);
    return sqrt(Vector3.dot(c, c));
}
public float crossProduct(Vector3 p1, Vector3 p2, Vector3 p3) {
    return (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);
}
public boolean isPointOnLineSegment(Vector3 p1, Vector3 p2, Vector3 p3) {
    if(Math.abs(crossProduct(p1, p2, p3)) > 1e-6f) return false;
    return (Math.min(p1.x, p2.x) <= p3.x && p3.x <= Math.max(p1.x, p2.x) &&
            Math.min(p1.y, p2.y) <= p3.y && p3.y <= Math.max(p1.y, p2.y));
}
// 計算兩條線段的交點
private Vector3 intersection(Line p, Line q) {
    float denom = (p.point1.x - p.point2.x) * (q.point1.y - q.point2.y) - (p.point1.y - p.point2.y) * (q.point1.x - q.point2.x);
    float intersectX = ((p.point1.x * p.point2.y - p.point1.y * p.point2.x) * (q.point1.x - q.point2.x) - (p.point1.x - p.point2.x) * (q.point1.x * q.point2.y - q.point1.y * q.point2.x)) / denom;
    float intersectY = ((p.point1.x * p.point2.y - p.point1.y * p.point2.x) * (q.point1.y - q.point2.y) - (p.point1.y - p.point2.y) * (q.point1.x * q.point2.y - q.point1.y * q.point2.x)) / denom;
    return new Vector3(intersectX, intersectY, 0);
}
public boolean pnpoly(float x, float y, Vector3[] vertexes) {
    // TODO HW2 
    // You need to check the coordinate p(x,v) if inside the vertices. 
    // If yes return true, vice versa.
    // ray casting
    int intersections = 0;
    Vector3 tmp = new Vector3(x, y, 0);
    for(int i = 0; i < vertexes.length; ++i){
        Vector3 p1 = vertexes[i];
        Vector3 p2 = vertexes[(i + 1) % vertexes.length];
        // 在線段上
        boolean onEdge = isPointOnLineSegment(vertexes[i], vertexes[(i + 1) % vertexes.length], tmp);
        if(onEdge){
            return true;
        }
        // 是否可以穿透該條線
        if ((p1.y > tmp.y) != (p2.y > tmp.y)) {
            // 射線的交點
            float xIntersection = p1.x + (tmp.y - p1.y) * (p2.x - p1.x) / (p2.y - p1.y);
            if (tmp.x < xIntersection) {
                intersections++;
            }
        }
    }
    return (intersections % 2 == 1);
}

public Vector3[] findBoundBox(Vector3[] v) {
    
    
    // TODO HW2 
    // You need to find the bounding box of the vertices v.
    // r1 -------
    //   |   /\  |
    //   |  /  \ |
    //   | /____\|
    //    ------- r2

    float minX = Float.MAX_VALUE, minY = Float.MAX_VALUE;
    float maxX = -Float.MAX_VALUE, maxY = -Float.MAX_VALUE;

    for (Vector3 vertex : v) {
        minX = Math.min(minX, vertex.x);
        minY = Math.min(minY, vertex.y);
        maxX = Math.max(maxX, vertex.x);
        maxY = Math.max(maxY, vertex.y);
    }

    return new Vector3[] { new Vector3(minX, minY, 0), new Vector3(maxX, maxY, 0) };

}

public Vector3[] Sutherland_Hodgman_algorithm(Vector3[] points, Vector3[] boundary) {
    ArrayList<Vector3> input = new ArrayList<Vector3>();
    ArrayList<Vector3> output = new ArrayList<Vector3>();
    for (int i = 0; i < points.length; i += 1) {
        input.add(points[i]);
    }
    // TODO HW2
    // You need to implement the Sutherland Hodgman Algorithm in this section.
    // The function you pass 2 parameter. One is the vertexes of the shape "points".
    // And the other is the vertices of the "boundary".
    // The output is the vertices of the polygon.
    for (int i = 0; i < boundary.length && input.size() != 0; ++i) {
        Vector3 boundary1 = boundary[i];
        Vector3 boundary2 = boundary[(i + 1) % boundary.length];
        Line p = new Line(boundary1, boundary2);
        // 線段是順時針放
        boolean preInside = crossProduct(boundary1, boundary2, input.get(input.size() - 1)) <= 0;
        for (int j = 0; j < input.size(); ++j) {
            boolean curInside = crossProduct(boundary1, boundary2, input.get(j)) <= 0;
            Line q = new Line(input.get((j - 1 + input.size()) % input.size()), input.get(j));
            if (curInside) {
                // 當前點在邊界內
                if (!preInside) {
                    output.add(intersection(p, q)); // 加入交點
                }
                output.add(input.get(j)); // 加入當前點
            } else {
                if (preInside) {
                    output.add(intersection(p, q)); // 加入交點
                }
            }
            preInside = curInside;
        }
        input.clear();  // 清空現有內容
        input.addAll(output);  // 直接把 output 放入 input，減少複製操作
        output.clear();
    }
    // output = input;
    Vector3[] result = new Vector3[input.size()];
    for (int i = 0; i < result.length; ++i) {
        result[i] = input.get(i);
    }
    return result;
}


  public void settings() { size(1000, 600); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "HW2" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
