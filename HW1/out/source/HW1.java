/* autogenerated by Processing revision 1293 on 2024-10-20 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class HW1 extends PApplet {

ShapeButton lineButton;
ShapeButton circleButton;
ShapeButton polygonButton;
ShapeButton ellipseButton;
ShapeButton curveButton;
ShapeButton pencilButton;
ShapeButton eraserButton;
ColorButton colorButton;

Button clearButton;

ShapeRenderer shapeRenderer;
ArrayList<ShapeButton> shapeButton;
float eraserSize = 20;

public void setup() {
    /* size commented out by preprocessor */;
    background(255);
    shapeRenderer = new ShapeRenderer();
    initButton();

}

public void draw() {

    background(255);
    for (ShapeButton sb : shapeButton) {
        sb.run(() -> {
            sb.beSelect();
            shapeRenderer.setRenderer(sb.getRendererType());
        });
    }

    clearButton.run(() -> {
        shapeRenderer.clear();
    });
    
    colorButton.run(() -> {
    });
    
    shapeRenderer.box.show();

    shapeRenderer.run();

}

public void resetButton() {
    for (ShapeButton sb : shapeButton) {
        sb.setSelected(false);
    }
}

public void initButton() {
    shapeButton = new ArrayList<ShapeButton>();
    lineButton = new ShapeButton(10, 10, 30, 30) {
        @Override
        public void show() {
            super.show();
            stroke(0);
            line(pos.x + 2, pos.y + 2, pos.x + size.x - 2, pos.y + size.y - 2);
        }

        @Override
        public Renderer getRendererType() {
            return new LineRenderer();
        }
    };

    lineButton.setBoxAndClickColor(color(250), color(150));
    shapeButton.add(lineButton);

    circleButton = new ShapeButton(45, 10, 30, 30) {
        @Override
        public void show() {
            super.show();
            stroke(0);
            circle(pos.x + size.x / 2, pos.y + size.y / 2, size.x - 2);
        }

        @Override
        public Renderer getRendererType() {
            return new CircleRenderer();
        }
    };
    circleButton.setBoxAndClickColor(color(250), color(150));
    shapeButton.add(circleButton);

    polygonButton = new ShapeButton(80, 10, 30, 30) {
        @Override
        public void show() {
            super.show();
            stroke(0);
            line(pos.x + 2, pos.y + 2, pos.x + size.x - 2, pos.y + 2);
            line(pos.x + 2, pos.y + size.y - 2, pos.x + size.x - 2, pos.y + size.y - 2);
            line(pos.x + size.x - 2, pos.y + 2, pos.x + size.x - 2, pos.y + size.y - 2);
            line(pos.x + 2, pos.y + 2, pos.x + 2, pos.y + size.y - 2);
        }

        @Override
        public Renderer getRendererType() {
            return new PolygonRenderer();
        }

    };

    polygonButton.setBoxAndClickColor(color(250), color(150));
    shapeButton.add(polygonButton);

    ellipseButton = new ShapeButton(115, 10, 30, 30) {
        @Override
        public void show() {
            super.show();
            stroke(0);
            ellipse(pos.x + size.x / 2, pos.y + size.y / 2, size.x - 2, size.y * 2 / 3);
        }

        @Override
        public Renderer getRendererType() {
            return new EllipseRenderer();
        }

    };

    ellipseButton.setBoxAndClickColor(color(250), color(150));
    shapeButton.add(ellipseButton);

    curveButton = new ShapeButton(150, 10, 30, 30) {
        @Override
        public void show() {
            super.show();
            stroke(0);
            bezier(pos.x, pos.y, pos.x, pos.y + size.y, pos.x + size.x, pos.y, pos.x + size.x, pos.y + size.y);
        }

        @Override
        public Renderer getRendererType() {
            return new CurveRenderer();
        }

    };

    curveButton.setBoxAndClickColor(color(250), color(150));
    shapeButton.add(curveButton);

    clearButton = new Button(width - 50, 10, 30, 30);
    clearButton.setBoxAndClickColor(color(250), color(150));
    clearButton.setImage(loadImage("clear.png"));

    pencilButton = new ShapeButton(185, 10, 30, 30) {
        @Override
        public Renderer getRendererType() {
            return new PencilRenderer();
        }
    };
    pencilButton.setImage(loadImage("pencil.png"));

    pencilButton.setBoxAndClickColor(color(250), color(150));
    shapeButton.add(pencilButton);

    eraserButton = new ShapeButton(220, 10, 30, 30) {
        @Override
        public Renderer getRendererType() {
            return new EraserRenderer();
        }
    };
    eraserButton.setImage(loadImage("eraser.png"));

    eraserButton.setBoxAndClickColor(color(250), color(150));
    shapeButton.add(eraserButton);

    colorButton = new ColorButton(255, 10, 30, 30);
}

public void keyPressed() {
    if (key == 'z' || key == 'Z') {
        shapeRenderer.popShape();
    }

}

public void mouseWheel(MouseEvent event) {
    float e = event.getCount();
    if (e < 0)
        eraserSize += 1;
    else if (e > 0)
        eraserSize -= 1;
    eraserSize = max(min(eraserSize, 30), 4);
}
public class Box {
    public Vector3 pos;
    public Vector3 size;
    protected int box_color = color(0);

    public Box(float x, float y, float w, float h) {
        pos = new Vector3(x, y, 0);
        size = new Vector3(w, h, 0);
    }

    public Box(Vector3 p, Vector3 s) {
        pos = p;
        size = s;
    }

    public Box setBoxColor(int c) {
        box_color = c;
        return this;
    }

    public void show() {
        fill(box_color);
        noStroke();
        rect(pos.x, pos.y, size.x, size.y);
    }

    public boolean checkInSide(Vector3 p) {
        if (p.x >= pos.x && p.x <= pos.x + size.x && p.y >= pos.y && p.y <= pos.y + size.y)
            return true;
        return false;
    }

    public boolean checkInSide() {
        if (mouseX >= pos.x && mouseX <= pos.x + size.x && mouseY >= pos.y && mouseY <= pos.y + size.y)
            return true;
        return false;
    }

}

public class Button extends Box {
    protected int click_color;
    protected boolean press = false;
    protected boolean once = false;
    protected PImage image = null;

    public Button(float x, float y, float w, float h) {
        super(x, y, w, h);
    }

    public Button(Vector3 p, Vector3 s) {
        super(p, s);
    }

    public Button setImage(PImage img) {
        image = img;
        return this;
    }

    public void run(ButtonFunction bf) {
        click(bf);
        show();
    }

    @Override
    public void show() {
        if (!press)
            fill(box_color);
        else
            fill(click_color);
        noStroke();
        rect(pos.x, pos.y, size.x, size.y);
        if (image != null)
            image(image, pos.x, pos.y, size.x, size.y);
    }

    public void setClickColor(int c) {
        click_color = c;
    }

    public Button setBoxAndClickColor(int c1, int c2) {
        setBoxColor(c1);
        setClickColor(c2);
        return this;
    }

    public void click(ButtonFunction bf) {

        if (!checkInSide())
            return;
        if (mousePressed) {
            press = true;
            if (!once) {
                bf.function();
                once = true;
            }
        } else {
            press = false;
            once = false;
        }
    }

}

public class ShapeButton extends Button {
    private boolean selected = false;

    public ShapeButton(float x, float y, float w, float h) {
        super(x, y, w, h);
    }

    public ShapeButton(Vector3 p, Vector3 s) {
        super(p, s);
    }

    @Override
    public void show() {
        super.show();
        if (selected) {
            stroke(255, 0, 0);
            noFill();
            rect(pos.x - 2, pos.y - 2, size.x + 4, size.y + 4);
        }
    }

    public void beSelect() {
        resetButton();
        setSelected(true);
    }

    public void setSelected(boolean b) {
        selected = b;
    }

    public Renderer getRendererType() {
        return null;
    }
}

public class ColorButton extends Button {
    // 顏色與圖片數組
    private int[] colors = new int[8];
    private PImage[] images = new PImage[8];

    // 當前選中的顏色和圖片
    private int currentColor;
    private PImage currentImage;
    private int selectedColorIndex = 0; // 顏色與圖片的索引

    public ColorButton(float x, float y, float w, float h) {
        super(x, y, w, h);

        // 初始化顏色
        colors[0] = color(0, 0, 0);       // black
        colors[1] = color(255, 0, 0);     // red
        colors[2] = color(0, 255, 0);     // green
        colors[3] = color(0, 0, 255);     // blue
        colors[4] = color(255, 255, 0);   // yellow
        colors[5] = color(0, 255, 255);   // cray
        colors[6] = color(255, 0, 255);   // purple
        colors[7] = color(255, 255, 255); // white

        // 初始化圖片
        images[0] = loadImage("black.png");
        images[1] = loadImage("red.png");
        images[2] = loadImage("green.png");
        images[3] = loadImage("blue.png");
        images[4] = loadImage("yellow.png");
        images[5] = loadImage("cray.png");
        images[6] = loadImage("purple.png");
        images[7] = loadImage("white.png");

        // 初始選中的顏色和圖片
        currentColor = colors[selectedColorIndex];
        currentImage = images[selectedColorIndex];
    }

    @Override
    public void show() {
        // 繪製當前顏色
        fill(currentColor);
        noStroke();
        rect(pos.x, pos.y, size.x, size.y);

        // 顯示當前圖片
        if (currentImage != null) {
            image(currentImage, pos.x, pos.y, size.x, size.y);
        }

        // 如果按鈕被按下，顯示紅色邊框
        if (press) {
            stroke(255, 0, 0);
            noFill();
            rect(pos.x - 2, pos.y - 2, size.x + 4, size.y + 4);
        }
    }

    @Override
    public void click(ButtonFunction bf) {
        // 按鈕點擊事件
        if (!checkInSide())
            return;
        if (mousePressed) {
            press = true;
            if (!once) {
                // 循環選擇下一個顏色和圖片
                selectedColorIndex = (selectedColorIndex + 1) % colors.length;
                currentColor = colors[selectedColorIndex];
                currentImage = images[selectedColorIndex];
                bf.function(); // 執行傳入的函數
                once = true;
            }
        } else {
            press = false;
            once = false;
        }
    }

    // 返回當前選中的顏色
    public int getCurrentColor() {
        return currentColor;
    }

    // 手動設置顏色
    public void setCurrentColor(int c) {
        currentColor = c;
    }
}
@FunctionalInterface
interface ButtonFunction {
    void function();
}

public interface Shape {
    public void drawShape();
}

public class Point implements Shape {
    ArrayList<Vector3> points = new ArrayList<Vector3>();

    public Point(ArrayList<Vector3> p) {
        points = p;
    }

    @Override
    public void drawShape() {
        if (points.size() <= 1)
            return;
        for (int i = 0; i < points.size() - 1; i++) {
            Vector3 p1 = points.get(i);
            Vector3 p2 = points.get(i + 1);
            CGLine(p1.x, p1.y, p2.x, p2.y);
        }
    }
}

public class Line implements Shape {
    Vector3 point1;
    Vector3 point2;

    public Line() {
    };

    public Line(Vector3 v1, Vector3 v2) {
        point1 = v1;
        point2 = v2;
    }

    @Override
    public void drawShape() {
        CGLine(point1.x, point1.y, point2.x, point2.y);
    }

}

public class Circle implements Shape {
    Vector3 center;
    float radius;

    public Circle() {
    }

    public Circle(Vector3 v1, float r) {
        center = v1;
        radius = r;
    }

    @Override
    public void drawShape() {
        CGCircle(center.x, center.y, radius);
    }
}

public class Polygon implements Shape {
    ArrayList<Vector3> verties = new ArrayList<Vector3>();

    public Polygon(ArrayList<Vector3> v) {
        verties = v;
    }

    @Override
    public void drawShape() {
        if (verties.size() <= 0)
            return;
        for (int i = 0; i <= verties.size(); i++) {
            Vector3 p1 = verties.get(i % verties.size());
            Vector3 p2 = verties.get((i + 1) % verties.size());
            CGLine(p1.x, p1.y, p2.x, p2.y);
        }
    }
}

public class Ellipse implements Shape {
    Vector3 center;
    float radius1, radius2;

    public Ellipse() {
    }

    public Ellipse(Vector3 cen, float r1, float r2) {
        center = cen;
        radius1 = r1;
        radius2 = r2;
    }

    @Override
    public void drawShape() {
        CGEllipse(center.x, center.y, radius1, radius2);
    }
}

public class Curve implements Shape {
    Vector3 cpoint1, cpoint2, cpoint3, cpoint4;
    float radius1, radius2;

    public Curve() {
    }

    public Curve(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4) {
        cpoint1 = p1;
        cpoint2 = p2;
        cpoint3 = p3;
        cpoint4 = p4;
    }

    @Override
    public void drawShape() {
        CGCurve(cpoint1, cpoint2, cpoint3, cpoint4);
    }
}

public class EraseArea implements Shape {
    Vector3 point1, point2;

    public EraseArea() {
    }

    public EraseArea(Vector3 p1, Vector3 p2) {
        point1 = p1;
        point2 = p2;
    }

    @Override
    public void drawShape() {
        CGEraser(point1, point2);
    }
}
public class ShapeRenderer{
    private Box box;
    public Renderer renderer;
    private ArrayList<Shape> shapes;
    public ShapeRenderer(){
      box = new Box(20,50,width-40,height-100);
      box.setBoxColor(250);
      shapes = new ArrayList<Shape>();
    }
    
    public void run(){      
      
      shapes.forEach(Shape::drawShape);
      if(renderer!=null) renderer.render();
    }
    
    public void setRenderer(Renderer r){
        renderer = r;
    }
    
    public void addShape(Shape s){
      shapes.add(s);
    }   
    
    public boolean checkInBox(Vector3 v){
      return box.checkInSide(v);
    }
    
    public void popShape(){
        if(shapes.size()<=0) return;
        shapes.remove(shapes.size()-1);
    }
    public void clear(){
        shapes.clear();
    }
}


public interface Renderer{
    void render();
}

public class PencilRenderer implements Renderer{
    
    private ArrayList<Vector3> points = new ArrayList<Vector3>();
    private boolean once;
    @Override 
    public void render(){
        if(!shapeRenderer.checkInBox(new Vector3(mouseX,mouseY,0))) return;
        if(mousePressed){
            once = false;
            points.add(new Vector3(mouseX,mouseY,0));
        }else{
            if(!once){
                once = true;
                shapeRenderer.addShape(new Point(points)); 
                points = new ArrayList<Vector3>();
            }
        }
        if(points.size()<=1) return;  
        for(int i=0;i<points.size()-1;i++){
            Vector3 p1 = points.get(i);
            Vector3 p2 = points.get(i+1);
            CGLine(p1.x,p1.y,p2.x,p2.y);
        }
        
    }

}

public class LineRenderer implements Renderer{
    private boolean once;
    private boolean first_click;
    private Vector3 first_point;
    private Vector3 second_point;
    
    @Override
    public void render(){
        if(!shapeRenderer.checkInBox(new Vector3(mouseX,mouseY,0))) return;
        if(mousePressed&& mouseButton == LEFT){
            if(!once){
                if(!first_click) first_point = new Vector3(mouseX,mouseY,0);
                if(first_click) second_point = new Vector3(mouseX,mouseY,0);             
                if(first_click){
                    shapeRenderer.addShape(new Line(first_point,second_point));
                    first_point = null;
                    second_point = null;
                }
                first_click = !first_click;
                once = true;
            }
        }else if(mousePressed&& mouseButton == RIGHT){
            first_click = false;          
            first_point = null;
            second_point = null;
        }
        else{
            once = false;
        }     
        if(first_click && first_point!=null) CGLine(first_point.x,first_point.y,mouseX,mouseY);      
    }
}

public class CircleRenderer implements Renderer{
  
    private boolean once;
    private boolean first_click;
    private Vector3 first_point;
    private Vector3 second_point;
    
    @Override
    public void render(){
        if(!shapeRenderer.checkInBox(new Vector3(mouseX,mouseY,0))) return;
        if(mousePressed&& mouseButton == LEFT){
              if(!once){
                  if(!first_click) first_point = new Vector3(mouseX,mouseY,0);
                  if(first_click) second_point = new Vector3(mouseX,mouseY,0);             
                  if(first_click){
                      shapeRenderer.addShape(new Circle(first_point,distance(first_point,second_point)));
                      first_point = null;
                      second_point = null;
                  }
                  first_click = !first_click;
                  once = true;
              }
          }else if(mousePressed&& mouseButton == RIGHT){
              first_click = false;          
              first_point = null;
              second_point = null;
          }
          else{
              once = false;
          }           
          if(first_click && first_point!=null) CGCircle(first_point.x,first_point.y,distance(first_point,new Vector3(mouseX,mouseY,0)));
    }
}

public class PolygonRenderer implements Renderer{
  
    private boolean once;
    private ArrayList<Vector3> verties = new ArrayList<Vector3>();
  
    @Override
    public void render(){
        if(!shapeRenderer.checkInBox(new Vector3(mouseX,mouseY,0))) return;
        if(mousePressed&& mouseButton == LEFT){
            if(!once){
                verties.add(new Vector3(mouseX,mouseY,0));
                once = true;
            }
        }else if(mousePressed&& mouseButton == RIGHT){
            if(!once){
              shapeRenderer.addShape(new Polygon(verties));
              verties = new ArrayList<Vector3>();
              once = true;
            }
        }
        else{
            once = false;
        }
        if(verties.size()>0){
            for(int i=0;i<verties.size()-1;i++){
                Vector3 p1 = verties.get(i);
                Vector3 p2 = verties.get(i+1);
                CGLine(p1.x,p1.y,p2.x,p2.y);
            }
            Vector3 p = verties.get(verties.size()-1);
            CGLine(p.x,p.y,mouseX,mouseY);
        }     
    }
} 

public class EllipseRenderer implements Renderer{
  private boolean once;
  private int times;
  private Vector3 center;
  private float radius1 = 0;
  private float radius2 = 0;
  
  @Override
  public void render(){
      if(!shapeRenderer.checkInBox(new Vector3(mouseX,mouseY,0))) return;
        if(mousePressed&& mouseButton == LEFT){
            if(!once){
                if(times==0) center = new Vector3(mouseX,mouseY,0);
                if(times==1){
                    float dist = abs(center.x - mouseX);
                    radius1 = dist;
                    radius2 = dist;
                }
                if(times==2){
                    float dist = abs(center.y - mouseY);                  
                    radius2 = dist;
                    shapeRenderer.addShape(new Ellipse(center,radius1,radius2));
                }
                times += 1;
                times %=3;
                once = true;
            }
        }else if(mousePressed&& mouseButton == RIGHT){
            times = 0;
            center = null;
        }
        else{
            once = false;
        }
        if(times==0) return;
        if(times==1) {
          float dist = abs(center.x - mouseX);
          CGEllipse(center.x,center.y,dist,dist);
        }
        if(times==2){
          float dist = abs(center.y - mouseY);
          CGEllipse(center.x,center.y,radius1,dist);
        }

  }

}

class EraserRenderer implements Renderer{

  @Override
  public void render(){
      if(!shapeRenderer.checkInBox(new Vector3(mouseX,mouseY,0))) return;
     // loadPixels();
      noFill();
      stroke(0);
      rect(mouseX - eraserSize/2,mouseY - eraserSize/2,eraserSize,eraserSize);
      if(mousePressed&& mouseButton == LEFT){
          shapeRenderer.addShape(new EraseArea(new Vector3(mouseX - eraserSize/2,mouseY - eraserSize/2,0),new Vector3(mouseX + eraserSize/2,mouseY + eraserSize/2,0)));
          
      }
      //updatePixels();
     
  }

}

class CurveRenderer implements Renderer{
  private boolean once;
  private int times;
  private Vector3 cp1;
  private Vector3 cp2;
  private Vector3 cp3;
  private Vector3 cp4;
  
  @Override
  public void render(){
      if(!shapeRenderer.checkInBox(new Vector3(mouseX,mouseY,0))) return;
      if(mousePressed&& mouseButton == LEFT){
          if(!once){   
              switch(times){
                case 0:
                  cp1 = new Vector3(mouseX,mouseY,0);
                  break;
                case 1:
                  cp2 = new Vector3(mouseX,mouseY,0);
                  break;
                case 2:
                  cp3 = new Vector3(mouseX,mouseY,0);
                  break;
                case 3:
                  cp4 = new Vector3(mouseX,mouseY,0);
                  shapeRenderer.addShape(new Curve(cp1,cp3,cp4,cp2));
                 
                  break;
              }
              times += 1;
              times %=4;
              once = true;
          }
      }else if(mousePressed&& mouseButton == RIGHT){
          times = 0;          
      }
      else{
          once = false;
      }
      Vector3 cp = new Vector3(mouseX,mouseY,0);
      if(times==0) return;
      if(times==1) CGCurve(cp1,cp1,cp ,cp);
      if(times==2) CGCurve(cp1,cp,cp2 ,cp2);
      if(times==3) CGCurve(cp1,cp3,cp ,cp2);
      
  }
}
static final public class Vector3 {
    private float x;
    private float y;
    private float z;

    Vector3() {
        x = 0;
        y = 0;
        z = 0;
    }

    Vector3(float _a) {
        x = _a;
        y = _a;
        z = _a;
    }

    Vector3(float _x, float _y, float _z) {
        x = _x;
        y = _y;
        z = _z;
    }

    public float x() {
        return x;
    }

    public float y() {
        return y;
    }

    public float z() {
        return z;
    }

    public float xyz(int i) {
        if (i == 0)
            return x;
        else if (i == 1)
            return y;
        else
            return z;
    }

    public static Vector3 Zero() {
        return new Vector3(0);
    }

    public static Vector3 Ones() {
        return new Vector3(1);
    }

    public static Vector3 UnitX() {
        return new Vector3(1, 0, 0);
    }

    public static Vector3 UnitY() {
        return new Vector3(0, 1, 0);
    }

    public static Vector3 UnitZ() {
        return new Vector3(0, 0, 1);
    }

    public void set(float _x, float _y, float _z) {
        x = _x;
        y = _y;
        z = _z;
    }

    public void setZero() {
        x = 0.0f;
        y = 0.0f;
        z = 0.0f;
    }

    public void setOnes() {
        x = 1.0f;
        y = 1.0f;
        z = 1.0f;
    }

    public void setUnitX() {
        x = 1.0f;
        y = 0.0f;
        z = 0.0f;
    }

    public void setUnitY() {
        x = 0.0f;
        y = 1.0f;
        z = 0.0f;
    }

    public void setUnitZ() {
        x = 0.0f;
        y = 0.0f;
        z = 1.0f;
    }

    public static Vector3 add(Vector3 a, Vector3 b) {
        Vector3 result = new Vector3();
        result.x = a.x + b.x;
        result.y = a.y + b.y;
        result.z = a.z + b.z;
        return result;
    }

    public static Vector3 sub(Vector3 a, Vector3 b) {
        Vector3 result = new Vector3();
        result.x = a.x - b.x;
        result.y = a.y - b.y;
        result.z = a.z - b.z;
        return result;
    }

    public static Vector3 mult(float n, Vector3 a) {
        Vector3 result = new Vector3();
        result.x = n * a.x;
        result.y = n * a.y;
        result.z = n * a.z;
        return result;
    }

    public Vector3 mult(float n) {
        Vector3 result = new Vector3();
        result.x = n * x;
        result.y = n * y;
        result.z = n * z;
        return result;
    }

    public void product(float n) {

        x *= n;
        y *= n;
        z *= n;
    }

    public Vector3 dive(float n) {
        Vector3 result = new Vector3();
        result.x = x / n;
        result.y = y / n;
        result.z = z / n;
        return result;
    }

    public float minComponent() {
        return min(x, min(y, z));
    }

    public float maxComponent() {
        return max(x, max(y, z));
    }

    public static Vector3 cross(Vector3 a, Vector3 b) {
        Vector3 result = new Vector3();
        result.x = a.y * b.z - a.z * b.y;
        result.y = a.z * b.x - a.x * b.z;
        result.z = a.x * b.y - a.y * b.x;
        return result;
    }

    public static float dot(Vector3 a, Vector3 b) {
        return a.x * b.x + a.y * b.y + a.z * b.z;
    }

    public float norm() {
        return sqrt(x * x + y * y + z * z);
    }

    public void print() {
        println("x: " + x + " y: " + y + " z: " + z);
    }

    public Vector3 unit_vector() {
        return Vector3.mult(1 / this.norm(), this);
    }

    public void normalize() {
        float a = 1 / this.norm();
        this.product(a);
    }

    public static Vector3 unit_vector(Vector3 v) {
        return Vector3.mult(1 / v.norm(), v);
    }

    public Vector3 sub(Vector3 b) {
        Vector3 result = new Vector3();
        result.x = x - b.x;
        result.y = y - b.y;
        result.z = z - b.z;
        return result;
    }

    public Vector3 add(Vector3 b) {
        Vector3 result = new Vector3();
        result.x = x + b.x;
        result.y = y + b.y;
        result.z = z + b.z;
        return result;
    }

    public void minus(Vector3 b) {

        x -= b.x;
        y -= b.y;
        z -= b.z;
    }

    public void plus(Vector3 b) {

        x += b.x;
        y += b.y;
        z += b.z;
    }

    public float length_squared() {
        return x * x + y * y + z * z;
    }

    public float length() {
        return sqrt(this.length_squared());
    }

    public boolean near_zero() {
        float s = 1e-8f;
        return (abs(x) < s) && abs(y) < s && abs(z) < s;
    }

    public Vector3 product(Vector3 v) {
        Vector3 result = new Vector3();
        result.x = x * v.x;
        result.y = y * v.y;
        result.z = z * v.z;
        return result;
    }

    public Vector3 inv() {
        return new Vector3(1 / x, 1 / y, 1 / z);
    }

    public float magSq() {
        return x * x + y * y + z * z;
    }

    public void clipMag(float m) {
        float r = magSq() / (m * m);
        if (r > 1) {
            float sr = sqrt(r);
            x /= sr;
            y /= sr;
            z /= sr;
        }
    }

    public Vector3 copy() {
        return new Vector3(x, y, z);
    }

    public void copy(Vector3 b) {
        x = b.x;
        y = b.y;
        z = b.z;
    }

    @Override
    public String toString() {
        return "x : " + x + " y : " + y + " z : " + z;
    }
}
public void CGLine(float x1, float y1, float x2, float y2) {
    // TODO HW1
    // You need to implement the "line algorithm" in this section.
    // You can use the function line(x1, y1, x2, y2); to verify the correct answer.
    // However, remember to comment out before you submit your homework.
    // Otherwise, you will receive a score of 0 for this part.
    // Utilize the function drawPoint(x, y, color) to apply color to the pixel at
    // coordinates (x, y).
    // For instance: drawPoint(114, 514, color(255, 0, 0)); signifies drawing a red
    // point at (114, 514).

    /*
    stroke(0);
    noFill();
    line(x1,y1,x2,y2);
    */
    
    // f() = a*x + b*y + c = 0
    float a = Math.abs(y2 - y1);
    float b = Math.abs(x2 - x1);
    // next step
    float sx = (x1 > x2? -1 : 1);
    float sy = (y1 > y2? -1 : 1);

    // check slope dir
    float m = a / b;  
    float d = (m > 1? b - 0.5f * a : a - 0.5f * b); 
    while(true){
        drawPoint(x1, y1, color(0, 0, 0));
        if(m > 1 && y1 != y2){
            if(d > 0){
                d -= a;
                x1 += sx;
            }
            d += b;
            y1 += sy;
        }
        else if(m <= 1 && x1 != x2){
            if(d > 0){
                d -= b;
                y1 += sy;
            }
            d += a;
            x1 += sx;
        }
        else break;
    }
}

public void CGCircle(float x, float y, float r) {
    // TODO HW1
    // You need to implement the "circle algorithm" in this section.
    // You can use the function circle(x, y, r); to verify the correct answer.
    // However, remember to comment out before you submit your homework.
    // Otherwise, you will receive a score of 0 for this part.
    // Utilize the function drawPoint(x, y, color) to apply color to the pixel at
    // coordinates (x, y).

    /*
    stroke(0);
    noFill();
    circle(x,y,r*2);
    */

    // x^2 + y^2 = r^2
    float x1 = 0, y1 = r, d = 1.25f - r;
    float e = 3, se = -2 * r + 5;
    while(x1 <= y1){
        // circle is point symmetry
        drawPoint(x + x1, y + y1, color(0, 0, 0));
        drawPoint(x - x1, y + y1, color(0, 0, 0));
        drawPoint(x + x1, y - y1, color(0, 0, 0));
        drawPoint(x - x1, y - y1, color(0, 0, 0));
        drawPoint(x + y1, y + x1, color(0, 0, 0));
        drawPoint(x - y1, y + x1, color(0, 0, 0));
        drawPoint(x + y1, y - x1, color(0, 0, 0));
        drawPoint(x - y1, y - x1, color(0, 0, 0));
        if(d < 0){
            d += e;
        }
        else{
            --y1;
            d += se;
            se += 2;
        }
        e += 2; se += 2;
        ++x1; //no move, cross line
    }   
}

public void CGEllipse(float x, float y, float r1, float r2) {
    // TODO HW1
    // You need to implement the "ellipse algorithm" in this section.
    // You can use the function ellipse(x, y, r1,r2); to verify the correct answer.
    // However, remember to comment out the function before you submit your homework.
    // Otherwise, you will receive a score of 0 for this part.
    // Utilize the function drawPoint(x, y, color) to apply color to the pixel at
    // coordinates (x, y).
    // float x1 = 0;
    // float y1 = r2;

    /*
    stroke(0);
    noFill();
    ellipse(x,y,r1*2,r2*2);
    */

    // x ^ 2 / r1 ^ 1 + y ^ 2 / r2 ^ 2 = 1;
    float x1 = 0, y1 = r2;
    float r1_sq = r1 * r1;
    float r2_sq = r2 * r2;
    float dx = 2 * r2_sq * x1;
    float dy = 2 * r1_sq * y1;

    // Region 1: x / r1 ^ 2 的增加速度小於 y / r2 ^ 2 的減少速度
    float d1 = r2_sq - r1_sq * r2 + 0.25f * r1_sq;
    while (dx < dy) {
        // ellipse is point symmetry
        drawPoint(x + x1, y + y1, color(0, 0, 0));
        drawPoint(x - x1, y + y1, color(0, 0, 0));
        drawPoint(x + x1, y - y1, color(0, 0, 0));
        drawPoint(x - x1, y - y1, color(0, 0, 0));

        if (d1 < 0) {
            dx += 2 * r2_sq;
            d1 += dx + r2_sq;
        } else {
            y1--;
            dx += 2 * r2_sq;
            dy -= 2 * r1_sq;
            d1 += dx - dy + r2_sq;
        }
        x1++;
    }

    // Region 2:  y / r2 ^ 2 的減少速度大於或等於 x1/r1^2 的增加速度
    float d2 = r2_sq * (x1 + 0.5f) * (x1 + 0.5f) + r1_sq * (y1 - 1) * (y1 - 1) - r1_sq * r2_sq;
    while (y1 >= 0) {
        // ellipse is point symmetry
        drawPoint(x + x1, y + y1, color(0, 0, 0));
        drawPoint(x - x1, y + y1, color(0, 0, 0));
        drawPoint(x + x1, y - y1, color(0, 0, 0));
        drawPoint(x - x1, y - y1, color(0, 0, 0));

        if (d2 > 0) {
            dy -= 2 * r1_sq;
            d2 += r1_sq - dy;
        } else {
            x1++;
            dx += 2 * r2_sq;
            dy -= 2 * r1_sq;
            d2 += dx - dy + r1_sq;
        }
        y1--;
    }


}

public void CGCurve(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4) {
    // TODO HW1
    // You need to implement the "bezier curve algorithm" in this section.
    // You can use the function bezier(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x,
    // p4.y); to verify the correct answer.
    // However, remember to comment out before you submit your homework.
    // Otherwise, you will receive a score of 0 for this part.
    // Utilize the function drawPoint(x, y, color) to apply color to the pixel at
    // coordinates (x, y).

    
    stroke(0);
    noFill();
    bezier(p1.x,p1.y,p2.x,p2.y,p3.x,p3.y,p4.x,p4.y);
    

    // float t = 0;
    // float dt = 0.001;
    // // (1 - t) ^ 3 * p1 + (1 - t) ^ 2 * p2 + (1 - t) * p3 + p4
    // while (t <= 1) {
    //     float x = (float) (Math.pow(1 - t, 3) * p1.x + 3 * Math.pow(1 - t, 2) * t * p2.x + 3 * (1 - t) * Math.pow(t, 2) * p3.x + Math.pow(t, 3) * p4.x);
    //     float y = (float) (Math.pow(1 - t, 3) * p1.y + 3 * Math.pow(1 - t, 2) * t * p2.y + 3 * (1 - t) * Math.pow(t, 2) * p3.y + Math.pow(t, 3) * p4.y);

    //     drawPoint(x, y, color(0, 0, 0));

    //     t += dt;
    // }
}

public void CGEraser(Vector3 p1, Vector3 p2) {
    // TODO HW1
    // You need to erase the scene in the area defined by points p1 and p2 in this
    // section.
    // p1 ------
    // |       |
    // |       |
    // ------ p2
    // The background color is color(250);
    // You can use the mouse wheel to change the eraser range.
    // Utilize the function drawPoint(x, y, color) to apply color to the pixel at
    // coordinates (x, y).

    // left -> right, top -> bottom
    float left = min(p1.x, p2.x);
    float right = max(p1.x, p2.x);
    float top = min(p1.y, p2.y);
    float bottom = max(p1.y, p2.y);
    
    for (float x = left; x <= right; ++x) {
        for (float y = top; y <= bottom; ++y) {
            // bg color
            drawPoint(x, y, color(250)); 
        }
    }

}

public void drawPoint(float x, float y, int c) {
    
    // bar tools
    if(y <= 40){
        return;
    }
    stroke(c);
    point(x, y);
}

public float distance(Vector3 a, Vector3 b) {
    Vector3 c = a.sub(b);
    return sqrt(Vector3.dot(c, c));
}


  public void settings() { size(1000, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "HW1" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
