/* autogenerated by Processing revision 1293 on 2025-12-31 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import javax.swing.JFileChooser;
import javax.swing.filechooser.FileNameExtensionFilter;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class HW4 extends PApplet {




public Vector4 renderer_size;
static public float GH_FOV = 45.0f;
static public float GH_NEAR_MIN = 1e-3f;
static public float GH_NEAR_MAX = 1e-1f;
static public float GH_FAR = 1000.0f;
static public Vector3 AMBIENT_LIGHT = new Vector3(0.3f, 0.3f, 0.3f);

public boolean debug = false;

public float[] GH_DEPTH;
public PImage renderBuffer;

Engine engine;
Camera main_camera;
Vector3 cam_position;
Vector3 lookat;

Light basic_light;

public void setup() {
    /* size commented out by preprocessor */;
    renderer_size = new Vector4(20, 50, 520, 550);
    lookat = new Vector3(0, 0, 0);
    setDepthBuffer();
    main_camera = new Camera();
    cam_position = main_camera.transform.position;
    engine = new Engine();
    engine.renderer.addGameObject(basic_light);
    engine.renderer.addGameObject(main_camera);

}

public void setDepthBuffer(){
    renderBuffer = new PImage(PApplet.parseInt(renderer_size.z - renderer_size.x) , PApplet.parseInt(renderer_size.w - renderer_size.y));
    GH_DEPTH = new float[PApplet.parseInt(renderer_size.z - renderer_size.x) * PApplet.parseInt(renderer_size.w - renderer_size.y)];
    for(int i = 0 ; i < GH_DEPTH.length;i++){
        GH_DEPTH[i] = 1.0f;
        renderBuffer.pixels[i] = color(1.0f*250);
    }
}

public void draw() {
    // backGouraud(255);

    engine.run();
    // cameraControl();
}

public String selectFile() {
    JFileChooser fileChooser = new JFileChooser();
    fileChooser.setCurrentDirectory(new File("."));
    fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
    FileNameExtensionFilter filter = new FileNameExtensionFilter("Obj Files", "obj");
    fileChooser.setFileFilter(filter);

    int result = fileChooser.showOpenDialog(null);
    if (result == JFileChooser.APPROVE_OPTION) {
        String filePath = fileChooser.getSelectedFile().getAbsolutePath();
        return filePath;
    }
    return "";
}

// void cameraControl() {
//     // TODO HW3 (Optional)
//     // You can write your own camera control function here.
//     // Use setPositionOrientation(Vector3 position,Vector3 lookat) to modify the
//     // ViewMatrix.
//     // Hint : Use keyboard event and mouse click event to change the position of the
//     // camera.     
//     float movSpeed = 0.5f;
//     float maxX = 20.0f;
//     float maxY = 20.0f;
//     float maxZ = 0.0f;
//     float minX = -20.0f;
//     float minY = -20.0f;
//     float minZ = -20.0f;

//     if(keyPressed){
//         if(key == 'X'){
//             cam_position.x = min(cam_position.x + movSpeed, maxX);
//         }
//         if(key == 'x'){
//             cam_position.x = max(cam_position.x - movSpeed, minX);
//         }
//         if(key == 'Y'){
//             cam_position.y = min(cam_position.y + movSpeed, maxY);
//         }
//         if(key == 'y'){
//             cam_position.y = max(cam_position.y - movSpeed, minY);
//         }
//         if(key == 'Z'){
//             cam_position.z = min(cam_position.z + movSpeed, maxZ);
//         }
//         if(key == 'z'){
//             cam_position.z = max(cam_position.z - movSpeed, minZ);
//         }
//         if(key == 'W'){
//             cam_position.z = min(cam_position.z + movSpeed, maxZ);
//         }
//         if(key == 'w'){
//             cam_position.z = max(cam_position.z - movSpeed, minZ);
//         }
//          if(key == 'X'){
//             cam_position.x = min(cam_position.x + movSpeed, maxX);
//         }
//         if(key == 'x'){
//             cam_position.x = max(cam_position.x - movSpeed, minX);
//         }
//     }
//     main_camera.setPositionOrientation(cam_position, new Vector3(0,0,1));
// }
public class Box {
    public Vector3 pos;
    public Vector3 size;
    protected int box_color = color(0);

    public Box(float x, float y, float w, float h) {
        pos = new Vector3(x, y, 0);
        size = new Vector3(w, h, 0);
    }

    public Box(Vector3 p, Vector3 s) {
        pos = p;
        size = s;
    }

    public Box setBoxColor(int c) {
        box_color = c;
        return this;
    }

    public void show() {
        fill(box_color);
        noStroke();
        rect(pos.x, pos.y, size.x, size.y);
    }

    public boolean checkInSide(Vector3 p) {
        if (p.x >= pos.x && p.x <= pos.x + size.x && p.y >= pos.y && p.y <= pos.y + size.y)
            return true;
        return false;
    }

    public boolean checkInSide() {
        if (mouseX >= pos.x && mouseX <= pos.x + size.x && mouseY >= pos.y && mouseY <= pos.y + size.y)
            return true;
        return false;
    }
}

public class Button extends Box {
    protected int click_color;
    protected boolean press = false;
    protected boolean once = false;
    protected PImage image = null;

    public Button(float x, float y, float w, float h) {
        super(x, y, w, h);
    }

    public Button(Vector3 p, Vector3 s) {
        super(p, s);
    }

    public Button setImage(PImage img) {
        image = img;
        return this;
    }

    public void run(ButtonFunction bf) {
        click(bf);
        show();
    }

    @Override
    public void show() {
        if (!press)
            fill(box_color);
        else
            fill(click_color);
        noStroke();
        rect(pos.x, pos.y, size.x, size.y);
        if (image != null)
            image(image, pos.x, pos.y, size.x, size.y);
    }

    public void setClickColor(int c) {
        click_color = c;
    }

    public Button setBoxAndClickColor(int c1, int c2) {
        setBoxColor(c1);
        setClickColor(c2);
        return this;
    }

    public void click(ButtonFunction bf) {

        if (!checkInSide()) {
            return;
        }
        if (mousePressed) {
            press = true;
            if (!once) {
                bf.function();
                once = true;
            }
        } else {
            press = false;
            once = false;
        }
    }
}

public class HierarchyButton extends Button {
    String name;
    GameObject gameObject;

    public HierarchyButton(float x, float y, float w, float h) {
        super(x, y, w, h);
    }

    public HierarchyButton(Vector3 p, Vector3 s) {
        super(p, s);
    }

    @Override
    public void show() {
        super.show();
        textAlign(CENTER, CENTER);
        textSize(15);
        fill(0);
        text(name, pos.x + 100, pos.y + 15);
    }
}

public class ShapeButton extends Button {
    private boolean selected = false;

    public ShapeButton(float x, float y, float w, float h) {
        super(x, y, w, h);
    }

    public ShapeButton(Vector3 p, Vector3 s) {
        super(p, s);
    }

    @Override
    public void show() {
        super.show();
        if (selected) {
            stroke(255, 0, 0);
            noFill();
            rect(pos.x - 2, pos.y - 2, size.x + 4, size.y + 4);
        }
    }

    public void beSelect() {
        setSelected(true);
    }

    public void setSelected(boolean b) {
        selected = b;
    }

    public GameObject renderShape() {
        return null;
    }
}

public class MaterialButton extends Button {
    String name = "PhongMaterial";

    public MaterialButton(float x, float y, float w, float h) {
        super(x, y, w, h);
    }

    public MaterialButton(Vector3 p, Vector3 s) {
        super(p, s);
    }

    @Override
    public void show() {
        super.show();
        textAlign(LEFT, CENTER);
        textSize(15);
        fill(0);
        text(name, pos.x + 10, pos.y + 20);
    }
}
@FunctionalInterface
interface ButtonFunction{
    void function();
}
public class Camera extends GameObject {
    Matrix4 projection = new Matrix4();
    Matrix4 worldView = new Matrix4();
    int wid;
    int hei;
    float near;
    float far;

    Camera() {
        wid = 256;
        hei = 256;
        worldView.makeIdentity();
        projection.makeIdentity();
        transform.position = new Vector3(0, 0, -50);
        name = "Camera";
    }

    public Matrix4 inverseProjection() {
        Matrix4 invProjection = Matrix4.Zero();
        float a = projection.m[0];
        float b = projection.m[5];
        float c = projection.m[10];
        float d = projection.m[11];
        float e = projection.m[14];
        invProjection.m[0] = 1.0f / a;
        invProjection.m[5] = 1.0f / b;
        invProjection.m[11] = 1.0f / e;
        invProjection.m[14] = 1.0f / d;
        invProjection.m[15] = -c / (d * e);
        return invProjection;
    }

    public Matrix4 Matrix() {
        return projection.mult(worldView);
    }

    public void setSize(int w, int h, float n, float f) {
        wid = w;
        hei = h;
        near = n;
        far = f;
        // TODO HW3
        // This function takes four parameters, which are the width of the screen, the
        // height of the screen
        // the near plane and the far plane of the camera.
        // Where GH_FOV has been declared as a global variable.
        // Finally, pass the result into projection matrix.
        projection = new Matrix4();
        float aspect = wid / hei;
        float tan_fov = (float)Math.tan(Math.toRadians(GH_FOV / 2));
        projection.set(0, 1);
        projection.set(5, aspect);
        projection.set(10, far / (far - near) * tan_fov);
        projection.set(11, far * near / (near - far) * tan_fov);
        projection.set(14, tan_fov);
    }

    public void setPositionOrientation(Vector3 pos, float rotX, float rotY) {
        worldView = Matrix4.RotX(rotX).mult(Matrix4.RotY(rotY)).mult(Matrix4.Trans(pos.mult(-1)));
    }

    public void setPositionOrientation() {
        worldView = Matrix4.RotX(transform.rotation.x).mult(Matrix4.RotY(transform.rotation.y))
                .mult(Matrix4.Trans(transform.position.mult(-1)));
    }

    public void setPositionOrientation(Vector3 pos, Vector3 lookat) {
        // TODO HW3
        // This function takes two parameters, which are the position of the camera and
        // the point the camera is looking at.
        // We uses topVector = (0,1,0) to calculate the eye matrix.
        // Finally, pass the result into worldView matrix.
        Vector3 _forward = (lookat.sub(pos)).unit_vector();
        Vector3 up = Vector3.UnitY();
        Vector3 right = (Vector3.cross(_forward, up)).unit_vector();
        up = (Vector3.cross(right, _forward)).unit_vector();
        Matrix4 r = new Matrix4(right, up, _forward.mult(-1));
        r.set(15, 1.0f);
        Matrix4 tranE = Matrix4.Trans(pos.mult(-1));
        worldView = r.mult(tranE);
    }
}
public class PhongVertexShader extends VertexShader {
    public Vector4[][] main(Object[] attribute, Object[] uniform) {
        Vector3[] aVertexPosition = (Vector3[]) attribute[0];
        Vector3[] aVertexNormal = (Vector3[]) attribute[1];
        
        Matrix4 MVP = (Matrix4) uniform[0];
        Matrix4 M = (Matrix4) uniform[1];
        Vector4[] gl_Position = new Vector4[3];
        Vector4[] w_position = new Vector4[3];
        Vector4[] w_normal = new Vector4[3];

        for (int i = 0; i < gl_Position.length; i++) {
            gl_Position[i] = MVP.mult(aVertexPosition[i].getVector4(1.0f));
            w_position[i] = M.mult(aVertexPosition[i].getVector4(1.0f));
            w_normal[i] = M.mult(aVertexNormal[i].getVector4(0.0f));
        }

        Vector4[][] result = { gl_Position, w_position, w_normal };

        return result;
    }
}

public class PhongFragmentShader extends FragmentShader {
    public Vector4 main(Object[] varying) {
        Vector3 position = (Vector3) varying[0];
        Vector3 w_position = (Vector3) varying[1];
        Vector3 w_normal = (Vector3) varying[2];
        Vector3 albedo = (Vector3) varying[3];
        Vector3 kdksm = (Vector3) varying[4];
        Light light = basic_light;
        Camera cam = main_camera;

        // TODO HW4
        // In this section, we have passed in all the variables you need.
        // Please use these variables to calculate the result of Phong shading
        // for that point and return it to GameObject for rendering
        
        //ambient
        // Vector3 ambient;

        //diffusion
        Vector3 norm = w_normal.unit_vector();
        Vector3 lightDir = (light.transform.position.sub(position)).unit_vector();
        float diff = max(Vector3.dot(norm, lightDir), 0.0f);
        Vector3 diffuse = light.light_color.mult(diff * kdksm.x * light.intensity);

        //specular
        Vector3 viewDir = (cam.transform.position.sub(w_position)).unit_vector();
        Vector3 reflectDir = norm.mult(2 * Vector3.dot(lightDir, norm)).sub(lightDir);

        float spec = pow(max(Vector3.dot(viewDir, reflectDir), 0.0f), kdksm.z);
        Vector3 specular = light.light_color.mult(spec * kdksm.y * light.intensity);

        Vector3 result = (diffuse.add(specular)).product(albedo);

        return result.getVector4();
    }
}

public class FlatVertexShader extends VertexShader {
    public Vector4[][] main(Object[] attribute, Object[] uniform) {
        Vector3[] aVertexPosition = (Vector3[]) attribute[0];
        // 以三角形向量著色
        Vector3 normal = Vector3.cross(
            aVertexPosition[1].sub(aVertexPosition[0]),
            aVertexPosition[2].sub(aVertexPosition[0])
        ).unit_vector();
        Vector3[] aVertexNormal = new Vector3[3];
        for(int i = 0; i < 3; aVertexNormal[i] = normal, ++i);
        Matrix4 MVP = (Matrix4) uniform[0];
        Matrix4 M = (Matrix4) uniform[1];

        Vector4[] gl_Position = new Vector4[3];
        Vector4[] w_position = new Vector4[3];
        Vector4[] w_normal = new Vector4[3];

        // TODO HW4
        // Here you have to complete Flat shading.
        // We have instantiated the relevant Material, and you may be missing some
        // variables.
        // Please refer to the templates of Phong Material and Phong Shader to complete
        // this part.

        // Note: Here the first variable must return the position of the vertex.
        // Subsequent variables will be interpolated and passed to the fragment shader.
        // The return value must be a Vector4.

        for (int i = 0; i < gl_Position.length; i++) {
            gl_Position[i] = MVP.mult(aVertexPosition[i].getVector4(1.0f));
            w_position[i] = M.mult(aVertexPosition[i].getVector4(1.0f));
            w_normal[i] = M.mult(aVertexNormal[i].getVector4(0.0f));
        }

        Vector4[][] result = { gl_Position, w_position, w_normal };
        return result;
    }
}

public class FlatFragmentShader extends FragmentShader {
    public Vector4 main(Object[] varying) {
        Vector3 position = (Vector3) varying[0];
        Vector3 w_position = (Vector3) varying[1];
        Vector3 w_normal = (Vector3) varying[2];
        Vector3 albedo = (Vector3) varying[3];
        Vector3 kdksm = (Vector3) varying[4];
        Light light = basic_light;
        Camera cam = main_camera;

        // TODO HW4
        // Here you have to complete Flat shading.
        // We have instantiated the relevant Material, and you may be missing some
        // variables.
        // Please refer to the templates of Phong Material and Phong Shader to complete
        // this part.

        // Note : In the fragment shader, the first 'varying' variable must be its
        // screen position.
        // Subsequent variables will be received in order from the vertex shader.
        // Additional variables needed will be passed by the material later.D
        //ambient
        // Vector3 ambient;
        //diffusion
        Vector3 norm = w_normal.unit_vector();
        Vector3 lightDir = (light.transform.position.sub(position)).unit_vector();
        float diff = max(Vector3.dot(norm, lightDir), 0.0f);
        Vector3 diffuse = light.light_color.mult(diff * kdksm.x * light.intensity);

        //specular
        Vector3 viewDir = (cam.transform.position.sub(w_position)).unit_vector();
        Vector3 reflectDir = norm.mult(2 * Vector3.dot(lightDir, norm)).sub(lightDir);
        float spec = pow(max(Vector3.dot(viewDir, reflectDir), 0.0f), kdksm.z);
        Vector3 specular = light.light_color.mult(spec * kdksm.y * light.intensity);

        Vector3 result = (diffuse.add(specular)).product(albedo);

        return result.getVector4();
    }
}

public class GouraudVertexShader extends VertexShader {
    public Vector4[][] main(Object[] attribute, Object[] uniform) {
        Vector3[] aVertexPosition = (Vector3[]) attribute[0]; // 頂點位置數組
        Vector3[] aVertexNormal = (Vector3[]) attribute[1];   // 頂點法向量數組
        Matrix4 MVP = (Matrix4) uniform[0];                   // MVP 矩陣
        Matrix4 M = (Matrix4) uniform[1];                     
        Vector3 albedo = (Vector3) uniform[2];                // albedo
        Vector3 kdksm = (Vector3) uniform[3];                 // 材質屬性：k_d, k_s, shininess

        Light light = basic_light;
        Camera cam = main_camera;

        Vector4[] gl_Position = new Vector4[3]; 
        Vector4[] vertexColor = new Vector4[3];
        Vector4[] w_position = new Vector4[3];
        Vector4[] w_normal = new Vector4[3];

        // TODO HW4
        // Here you have to complete Gouraud shading.
        // We have instantiated the relevant Material, and you may be missing some
        // variables.
        // Please refer to the templates of Phong Material and Phong Shader to complete
        // this part.
        // Note: Here the first variable must return the position of the vertex.
        // Subsequent variables will be interpolated and passed to the fragment shader.
        // The return value must be a Vector4.
        for (int i = 0; i < gl_Position.length; i++) {
            gl_Position[i] = MVP.mult(aVertexPosition[i].getVector4(1.0f));
            w_position[i] = M.mult(aVertexPosition[i].getVector4(1.0f));
            w_normal[i] = M.mult(aVertexNormal[i].getVector4(0.0f));
            
            //diffusion
            Vector3 norm = w_normal[i].xyz().unit_vector();
            Vector3 lightDir = (light.transform.position.sub(gl_Position[i].xyz())).unit_vector();
            float diff = max(Vector3.dot(norm, lightDir), 0.0f);
            Vector3 diffuse = light.light_color.mult(diff * kdksm.x * light.intensity);

            //specular
            Vector3 viewDir = (cam.transform.position.sub(w_position[i].xyz())).unit_vector();
            Vector3 reflectDir = norm.mult(2 * Vector3.dot(lightDir, norm)).sub(lightDir);
            float spec = pow(max(Vector3.dot(viewDir, reflectDir), 0.0f), kdksm.z);
            Vector3 specular = light.light_color.mult(spec * kdksm.y * light.intensity);

            vertexColor[i] = (diffuse.add(specular)).product(albedo).getVector4();
        }

        Vector4[][] result = { gl_Position, vertexColor };

        return result;
    }
}

public class GouraudFragmentShader extends FragmentShader {
    public Vector4 main(Object[] varying) {
        Vector3 position = (Vector3) varying[0];
        Vector3 vectexColor = (Vector3) varying[1];
        // TODO HW4
        // Here you have to complete Gouraud shading.
        // We have instantiated the relevant Material, and you may be missing some
        // variables.
        // Please refer to the templates of Phong Material and Phong Shader to complete
        // this part.

        // Note : In the fragment shader, the first 'varying' variable must be its
        // screen position.
        // Subsequent variables will be received in order from the vertex shader.
        // Additional variables needed will be passed by the material later.

        return vectexColor.getVector4();
    }
}
public class GameObject {
    Transform transform;
    Mesh mesh;
    String name;
    Material material;
    MaterialEnum me;

    GameObject() {
        transform = new Transform();
    }

    GameObject(String fname) {
        transform = new Transform();
        setMesh(fname);
        String[] sn = fname.split("\\\\");
        name = sn[sn.length - 1].substring(0, sn[sn.length - 1].length() - 4);
        material = new PhongMaterial();
        me = MaterialEnum.PM;

    }

    public void reset() {
        transform.position.setZero();
        transform.rotation.setZero();
        transform.scale.setOnes();
    }

    public void setMesh(String fname) {
        mesh = new Mesh(fname);
    }

    public void Draw() {
       
        if(mesh==null) return;
        for (int i=0; i<mesh.triangles.size(); i++) {
            Triangle triangle = mesh.triangles.get(i);
            Vector3[] position = triangle.verts;
            Vector4[][] result = material.vertexShader(triangle,localToWorld());
            
            Vector4[] gl_Position = result[0];
            Vector3[] s_Position = new Vector3[3];
            for (int j = 0; j<gl_Position.length; j++) {
                s_Position[j] = gl_Position[j].homogenized();
            }
            Vector3[] boundbox = findBoundBox(s_Position);
            float minX = map(min( max(boundbox[0].x, -1.0f ), 1.0f), -1.0f, 1.0f, 0.0f, renderer_size.z - renderer_size.x);
            float maxX = map(min( max(boundbox[1].x, -1.0f ), 1.0f), -1.0f, 1.0f, 0.0f, renderer_size.z - renderer_size.x);
            float minY = map(min( max(boundbox[0].y, -1.0f ), 1.0f), -1.0f, 1.0f, 0.0f, renderer_size.w - renderer_size.y);
            float maxY = map(min( max(boundbox[1].y, -1.0f ), 1.0f), -1.0f, 1.0f, 0.0f, renderer_size.w - renderer_size.y);
            
            for (int y = PApplet.parseInt(minY); y < maxY; y++) {
                for (int x = PApplet.parseInt(minX); x < maxX; x++) {
                    float rx=map(x, 0.0f , renderer_size.z - renderer_size.x, -1, 1);
                    float ry=map(y, 0.0f, renderer_size.w - renderer_size.y, -1, 1);
                    if (!pnpoly(rx, ry, s_Position)) continue;
                    int index = PApplet.parseInt((renderer_size.w - renderer_size.y) - y - 1) * PApplet.parseInt(renderer_size.z - renderer_size.x) + x;
                    float[] abg = barycentric(new Vector3(rx,ry,0.0f) , gl_Position);
                    Vector4[] varing = new Vector4[result.length -1];
                    
                    for(int m=0;m<varing.length;m++){
                         varing[m] = interpolation(abg , result[m+1]);
                    }
                    
                    float z = interpolation(abg,s_Position).z;
                    Vector4 c = material.fragmentShader(new Vector3(rx,ry,z),varing);
                    
                    if (GH_DEPTH[index] > z) {
                        GH_DEPTH[index] = z;
                        renderBuffer.pixels[index] = color(c.x * 255, c.y*255, c.z*255);
                    }
                }
            }
        }        
        update();
    }

    public void update() {
    }

    public void debugDraw() {
        Matrix4 MVP = main_camera.Matrix().mult(localToWorld());
        if (mesh == null)
            return;
        for (int i = 0; i < mesh.triangles.size(); i++) {
            Triangle triangle = mesh.triangles.get(i);
            Vector3[] img_pos = new Vector3[3];
            for (int j = 0; j < 3; j++) {
                img_pos[j] = MVP.mult(triangle.verts[j].getVector4(1.0f)).homogenized();
            }

            for (int j = 0; j < img_pos.length; j++) {
                img_pos[j] = new Vector3(map(img_pos[j].x, -1, 1, renderer_size.x, renderer_size.z),
                        map(img_pos[j].y, 1, -1, renderer_size.y, renderer_size.w), img_pos[j].z);
            }

            CGLine(img_pos[0].x, img_pos[0].y, img_pos[1].x, img_pos[1].y);
            CGLine(img_pos[1].x, img_pos[1].y, img_pos[2].x, img_pos[2].y);
            CGLine(img_pos[2].x, img_pos[2].y, img_pos[0].x, img_pos[0].y);
        }
    }

    public String getGameObjectName() {
        return name;
    }

    public Matrix4 localToWorld() {
        // TODO HW3
        // You need to calculate the model Matrix here.
        return Matrix4.Trans(transform.position)
            .mult(Matrix4.RotY(transform.rotation.y)).
            mult(Matrix4.RotX(transform.rotation.x)).
            mult(Matrix4.RotZ(transform.rotation.z))
            .mult(Matrix4.Scale(transform.scale));
    }

    public Matrix4 worldToLocal() {
        return Matrix4.Scale(transform.scale.inv()).mult(Matrix4.RotZ(-transform.rotation.z))
                .mult(Matrix4.RotX(-transform.rotation.x)).mult(Matrix4.RotY(-transform.rotation.y))
                .mult(Matrix4.Trans(transform.position.mult(-1)));
    }

    public Vector3 forward() {
        return (Matrix4.RotZ(transform.rotation.z).mult(Matrix4.RotX(transform.rotation.y))
                .mult(Matrix4.RotY(transform.rotation.x)).zAxis()).mult(-1);
    }
}
class Light extends GameObject {
    Vector3 light_color;
    float intensity;

    Light() {
        light_color = new Vector3(0.8f, 0.8f, 0.8f);
        intensity = 1.0f;
        transform.position = new Vector3(10.0f, 10.0f, -10.0f);
        name = "Light";
    }
}
public abstract class Material {
    Vector3 albedo = new Vector3(0.9f, 0.9f, 0.9f);
    Shader shader;

    Material() {
        // TODO HW4
        // In the Material, pass the relevant attribute variables and uniform variables
        // you need.
        // In the attribute variables, include relevant variables about vertices,
        // and in the uniform, pass other necessary variables.
        // Please note that a Material will be bound to the corresponding Shader.
    }

    public abstract Vector4[][] vertexShader(Triangle triangle, Matrix4 M);

    public abstract Vector4 fragmentShader(Vector3 position, Vector4[] varing);

    public void attachShader(Shader s) {
        shader = s;
    }
}

public class DepthMaterial extends Material {
    DepthMaterial() {
        shader = new Shader(new DepthVertexShader(), new DepthFragmentShader());
    }

    public Vector4[][] vertexShader(Triangle triangle, Matrix4 M) {
        Matrix4 MVP = main_camera.Matrix().mult(M);
        Vector3[] position = triangle.verts;
        Vector4[][] r = shader.vertex.main(new Object[] { position }, new Object[] { MVP });
        return r;
    }

    public Vector4 fragmentShader(Vector3 position, Vector4[] varing) {
        return shader.fragment.main(new Object[] { position });
    }
}

public class PhongMaterial extends Material {
    Vector3 Ka = new Vector3(0.3f, 0.3f, 0.3f);
    float Kd = 0.5f;
    float Ks = 0.5f;
    float m = 20;

    PhongMaterial() {
        shader = new Shader(new PhongVertexShader(), new PhongFragmentShader());
    }

    public Vector4[][] vertexShader(Triangle triangle, Matrix4 M) {
        Matrix4 MVP = main_camera.Matrix().mult(M);
        Vector3[] position = triangle.verts;
        Vector3[] normal = triangle.normal;
        Vector3[] uvPosition = triangle.normal;
        Vector4[][] r = shader.vertex.main(new Object[] { position, normal, uvPosition }, new Object[] { MVP, M });
        return r;
    }

    public Vector4 fragmentShader(Vector3 position, Vector4[] varing) {

        return shader.fragment
                .main(new Object[] { position, varing[0].xyz(), varing[1].xyz(), albedo, new Vector3(Kd, Ks, m) });
    }

}

public class FlatMaterial extends Material {
    Vector3 Ka = new Vector3(0.3f, 0.3f, 0.3f);
    float Kd = 0.5f;
    float Ks = 0.5f;
    float m = 20;

    FlatMaterial() {
        shader = new Shader(new FlatVertexShader(), new FlatFragmentShader());
    }

    public Vector4[][] vertexShader(Triangle triangle, Matrix4 M) {
        Matrix4 MVP = main_camera.Matrix().mult(M);
        Vector3[] position = triangle.verts;
        Vector3[] normal = triangle.normal;
        Vector3[] texPosition = triangle.uvs;
        // TODO HW4
        // pass the uniform you need into the shader.

        // 調用頂點著色器，傳遞必要的屬性和 uniform

        Vector4[][] r = shader.vertex.main(new Object[] { position, normal }, new Object[] { MVP, M });
        return r;
    }

    public Vector4 fragmentShader(Vector3 position, Vector4[] varing) {

        return shader.fragment
                .main(new Object[] { position, varing[0].xyz(), varing[1].xyz(), albedo, new Vector3(Kd, Ks, m) });
    }
}

public class GouraudMaterial extends Material {
    Vector3 Ka = new Vector3(0.3f, 0.3f, 0.3f);
    float Kd = 0.5f;
    float Ks = 0.5f;
    float m = 20;
    GouraudMaterial() {
        shader = new Shader(new GouraudVertexShader(), new GouraudFragmentShader());
    }

    public Vector4[][] vertexShader(Triangle triangle, Matrix4 M) {
        Matrix4 MVP = main_camera.Matrix().mult(M);
        Vector3[] position = triangle.verts;
        Vector3[] normal = triangle.normal;

        // TODO HW4
        // pass the uniform you need into the shader.
        Vector4[][] r = shader.vertex.main(
            new Object[] { position, normal },
            new Object[] { MVP, M, albedo, new Vector3(Kd, Ks, m)}
        );
        return r;
    }

    public Vector4 fragmentShader(Vector3 position, Vector4[] varing) {
        return shader.fragment
                .main(new Object[] { position, varing[0].xyz() });
    }
}

public enum MaterialEnum {
    DM, FM, GM, PM;
}
static public class Matrix4{
  float m[]=new float[16];
  Matrix4(){
    makeZero();
  
  }
  Matrix4(float b){
    Fill(b);
  }
  public void Fill(float b){
    for(int i=0;i<m.length;i+=1){
      m[i]=b;
    }
  }
  public void set(int index, float b){
    m[index] = b;
  }
  Matrix4(Vector3 a,Vector3 b,Vector3 c){
     m[0]  = a.x;  m[1]  = a.y;  m[2]  = a.z;    m[3]  = 0.0f;
     m[4]  = b.x;  m[5]  = b.y;  m[6]  = b.z;    m[7]  = 0.0f;
     m[8]  = c.x;  m[9]  = c.y;  m[10] = c.z;    m[11] = 0.0f;
     m[12] = 0.0f; m[13] = 0.0f; m[14] = 0.0f;   m[15] = 0.0f;
  
  }
  
  public void makeZero(){
    Fill(0);
  }
  public void makeIdentity(){
     m[0]  = 1.0f; m[1]  = 0.0f; m[2]  = 0.0f; m[3]  = 0.0f;
     m[4]  = 0.0f; m[5]  = 1.0f; m[6]  = 0.0f; m[7]  = 0.0f;
     m[8]  = 0.0f; m[9]  = 0.0f; m[10] = 1.0f; m[11] = 0.0f;
     m[12] = 0.0f; m[13] = 0.0f; m[14] = 0.0f; m[15] = 1.0f;
    
  }
  public void makeRotX(float a) {
    // TODO HW2
    // You need to implement the rotation of x-axis matrix here.
    makeIdentity();
    Vector3 tmp = new Vector3(0, cos(a), sin(a));
    setYAxis(tmp);
    tmp = new Vector3(0, -sin(a), cos(a));
    setZAxis(tmp);
  }
  public void makeRotY(float a) {
    // TODO HW3
    // You need to implement the rotation of y-axis matrix here.
    makeIdentity();
    Vector3 tmp = new Vector3(cos(a), 0.0f, -sin(a));
    setXAxis(tmp);
    tmp = new Vector3(sin(a), 0.0f, cos(a));
    setZAxis(tmp);
  }
  public void makeRotZ(float a) {
    // TODO HW3
    // You need to implement the rotation of z-axis matrix here.
      makeIdentity();
      Vector3 tmp = new Vector3(cos(a), sin(a), 0.0f);
      setXAxis(tmp);
      tmp = new Vector3(-sin(a),cos(a), 0.0f);
      setYAxis(tmp);
  }
  
  public void makeTrans(Vector3 t) {
    // TODO HW2
    // You need to implement the translate matrix here.
    makeIdentity();
    setTranslation(t);
  }
  public void makeScale(Vector3 s) {
    // TODO HW2
    // You need to implement the scale matrix here.     
    makeIdentity();
    setScale(s);
  }
  
  public void makeMirror(){
    m[0]  = -1;  m[1]  = 0.0f; m[2]  = 0.0f; m[3]  = 0.0f;
    m[4]  = 0.0f; m[5]  = -1;  m[6]  = 0.0f; m[7]  = 0.0f;
    m[8]  = 0.0f; m[9]  = 0.0f; m[10] = 1;  m[11] = 0.0f;
    m[12] = 0.0f; m[13] = 0.0f; m[14] = 0.0f; m[15] = 1.0f;
  }
  public static Matrix4 Zero(){
    Matrix4 matrix=new Matrix4();
    matrix.makeZero();
    return matrix;
  }
  
  public static Matrix4 Identity(){
    Matrix4 matrix=new Matrix4();
    matrix.makeIdentity();
    return matrix;
  }
  public static Matrix4 Mirror(){
    Matrix4 matrix=new Matrix4();
    matrix.makeMirror();
    return matrix;
  }
  public static Matrix4 RotX(float a){
    Matrix4 matrix=new Matrix4();
    matrix.makeRotX(a);
    return matrix;
  }
  
  public static Matrix4 RotY(float a){
    Matrix4 matrix=new Matrix4();
    matrix.makeRotY(a);
    return matrix;
  }
  
  public static Matrix4 RotZ(float a){
    Matrix4 matrix=new Matrix4();
    matrix.makeRotZ(a);
    return matrix;
  }
  
  public static Matrix4 Trans(Vector3 t){
    Matrix4 matrix=new Matrix4();
    matrix.makeTrans(t);
    return matrix;
  }
  
  public static Matrix4 Scale(Vector3 s){
    Matrix4 matrix=new Matrix4();
    matrix.makeScale(s);
    return matrix;
  }
  
  public static Matrix4 Scale(float s){
    Matrix4 matrix=new Matrix4();
    matrix.makeScale(new Vector3(s));
    return matrix;
  }
  
  //setter
  public Vector3 xAxis(){
    return new Vector3(m[0], m[4], m[8]);
  }
  public Vector3 yAxis(){
    return new Vector3(m[1], m[5], m[9]);
  }
  public Vector3 zAxis(){
    return new Vector3(m[2], m[6], m[10]);
  }
  public Vector3 translation(){
    return new Vector3(m[3], m[7], m[11]);
  }
  public Vector3 Scale(){
    return new Vector3(m[0], m[5], m[10]);
  }
  
  //getter
  public void setTranslation(Vector3 t) {
    m[3] = t.x;
    m[7] = t.y;
    m[11] = t.z;
  }
  public void setXAxis(Vector3 t) {
    m[0] = t.x;
    m[4] = t.y;
    m[8] = t.z;
  }
  public void setYAxis(Vector3 t) {
    m[1] = t.x;
    m[5] = t.y;
    m[9] = t.z;
  }
  public void setZAxis(Vector3 t) {
    m[2] = t.x;
    m[6] = t.y;
    m[10] = t.z;
  }
  public void setScale(Vector3 s) {
    m[0] = s.x;
    m[5] = s.y;
    m[10] = s.z;
  }
  
  
  public Matrix4 transposed(){
    Matrix4 out=new Matrix4();
    out.m[0]  = m[0]; out.m[1]  = m[4]; out.m[2]  = m[8];  out.m[3]  = m[12];
    out.m[4]  = m[1]; out.m[5]  = m[5]; out.m[6]  = m[9];  out.m[7]  = m[13];
    out.m[8]  = m[2]; out.m[9]  = m[6]; out.m[10] = m[10]; out.m[11] = m[14];
    out.m[12] = m[3]; out.m[13] = m[7]; out.m[14] = m[11]; out.m[15] = m[15];
    return out;
  }
  
  public void Translate(Vector3 t) {
    m[3] += t.x;
    m[7] += t.y;
    m[11] += t.z;
  }
  public void stretch(Vector3 s) {
    m[0] *= s.x;
    m[5] *= s.y;
    m[10] *= s.z;
  }
  
  public Matrix4 add(Matrix4 b){
    Matrix4 out=new Matrix4();
    for(int i=0;i<m.length;i+=1){
      out.m[i]=m[i]+b.m[i];
    }
    return out;
  }
  public void plus(Matrix4 b){    
    for(int i=0;i<m.length;i+=1){
     m[i]+=b.m[i];
    }
  }
  
  public Matrix4 sub(Matrix4 b){
    Matrix4 out=new Matrix4();
    for(int i=0;i<m.length;i+=1){
      out.m[i]=m[i]-b.m[i];
    }
    return out;
  }
  public void minus(Matrix4 b){
    
    for(int i=0;i<m.length;i+=1){
     m[i]-=b.m[i];
    }
  }
  public Matrix4 mult(float b){
    Matrix4 out=new Matrix4();
    for(int i=0;i<m.length;i+=1){
      out.m[i]=m[i]*b;
    }
    return out;
  }
  
  public void times(float b){   
    for(int i=0;i<m.length;i+=1){
     m[i]*=b;
    }
  }  
  
  public Matrix4 div(float b){
    Matrix4 out=new Matrix4();
    for(int i=0;i<m.length;i+=1){
      out.m[i]=m[i]/b;
    }
    return out;
  }
  
  public void dive(float b){
    
    for(int i=0;i<m.length;i+=1){
     m[i]/=b;
    }
  }
  
  public Matrix4 mult(Matrix4 b){
    Matrix4 out=new Matrix4();
    out.m[0]  = b.m[0]*m[0]  + b.m[4]*m[1]  + b.m[8] *m[2]  + b.m[12]*m[3];
    out.m[1]  = b.m[1]*m[0]  + b.m[5]*m[1]  + b.m[9] *m[2]  + b.m[13]*m[3];
    out.m[2]  = b.m[2]*m[0]  + b.m[6]*m[1]  + b.m[10]*m[2]  + b.m[14]*m[3];
    out.m[3]  = b.m[3]*m[0]  + b.m[7]*m[1]  + b.m[11]*m[2]  + b.m[15]*m[3];

    out.m[4]  = b.m[0]*m[4]  + b.m[4]*m[5]  + b.m[8] *m[6]  + b.m[12]*m[7];
    out.m[5]  = b.m[1]*m[4]  + b.m[5]*m[5]  + b.m[9] *m[6]  + b.m[13]*m[7];
    out.m[6]  = b.m[2]*m[4]  + b.m[6]*m[5]  + b.m[10]*m[6]  + b.m[14]*m[7];
    out.m[7]  = b.m[3]*m[4]  + b.m[7]*m[5]  + b.m[11]*m[6]  + b.m[15]*m[7];

    out.m[8]  = b.m[0]*m[8]  + b.m[4]*m[9]  + b.m[8] *m[10] + b.m[12]*m[11];
    out.m[9]  = b.m[1]*m[8]  + b.m[5]*m[9]  + b.m[9] *m[10] + b.m[13]*m[11];
    out.m[10] = b.m[2]*m[8]  + b.m[6]*m[9]  + b.m[10]*m[10] + b.m[14]*m[11];
    out.m[11] = b.m[3]*m[8]  + b.m[7]*m[9]  + b.m[11]*m[10] + b.m[15]*m[11];

    out.m[12] = b.m[0]*m[12] + b.m[4]*m[13] + b.m[8] *m[14] + b.m[12]*m[15];
    out.m[13] = b.m[1]*m[12] + b.m[5]*m[13] + b.m[9] *m[14] + b.m[13]*m[15];
    out.m[14] = b.m[2]*m[12] + b.m[6]*m[13] + b.m[10]*m[14] + b.m[14]*m[15];
    out.m[15] = b.m[3]*m[12] + b.m[7]*m[13] + b.m[11]*m[14] + b.m[15]*m[15];
    return out;
  }
  
  public void times(Matrix4 b){
    m=this.mult(b).m;  
  }
  
  public Vector4 mult(Vector4 b){
    return new Vector4(
      m[0]*b.x  + m[1]*b.y  + m[2]*b.z  + m[3]*b.w,
      m[4]*b.x  + m[5]*b.y  + m[6]*b.z  + m[7]*b.w,
      m[8]*b.x  + m[9]*b.y  + m[10]*b.z + m[11]*b.w,
      m[12]*b.x + m[13]*b.y + m[14]*b.z + m[15]*b.w
    );
  }
  public Vector3 MulPoint(Vector3 b){
    Vector3 p=new Vector3(
      m[0] * b.x + m[1] * b.y + m[2] * b.z + m[3],
      m[4] * b.x + m[5] * b.y + m[6] * b.z + m[7],
      m[8] * b.x + m[9] * b.y + m[10] * b.z + m[11]
    );
    float w = m[12] * b.x + m[13] * b.y + m[14] * b.z + m[15];
    return p.dive(w);
  }
  public Vector3 MulDirection(Vector3 b){
    return new Vector3(
      m[0] * b.x + m[1] * b.y + m[2] * b.z,
      m[4] * b.x + m[5] * b.y + m[6] * b.z,
      m[8] * b.x + m[9] * b.y + m[10] * b.z
    );
  }
  public Matrix4 Inverse(){
    Matrix4 inv=new Matrix4();

    inv.m[0] = m[5] * m[10] * m[15] -
      m[5] * m[11] * m[14] -
      m[9] * m[6] * m[15] +
      m[9] * m[7] * m[14] +
      m[13] * m[6] * m[11] -
      m[13] * m[7] * m[10];

    inv.m[4] = -m[4] * m[10] * m[15] +
      m[4] * m[11] * m[14] +
      m[8] * m[6] * m[15] -
      m[8] * m[7] * m[14] -
      m[12] * m[6] * m[11] +
      m[12] * m[7] * m[10];

    inv.m[8] = m[4] * m[9] * m[15] -
      m[4] * m[11] * m[13] -
      m[8] * m[5] * m[15] +
      m[8] * m[7] * m[13] +
      m[12] * m[5] * m[11] -
      m[12] * m[7] * m[9];

    inv.m[12] = -m[4] * m[9] * m[14] +
      m[4] * m[10] * m[13] +
      m[8] * m[5] * m[14] -
      m[8] * m[6] * m[13] -
      m[12] * m[5] * m[10] +
      m[12] * m[6] * m[9];

    inv.m[1] = -m[1] * m[10] * m[15] +
      m[1] * m[11] * m[14] +
      m[9] * m[2] * m[15] -
      m[9] * m[3] * m[14] -
      m[13] * m[2] * m[11] +
      m[13] * m[3] * m[10];

    inv.m[5] = m[0] * m[10] * m[15] -
      m[0] * m[11] * m[14] -
      m[8] * m[2] * m[15] +
      m[8] * m[3] * m[14] +
      m[12] * m[2] * m[11] -
      m[12] * m[3] * m[10];

    inv.m[9] = -m[0] * m[9] * m[15] +
      m[0] * m[11] * m[13] +
      m[8] * m[1] * m[15] -
      m[8] * m[3] * m[13] -
      m[12] * m[1] * m[11] +
      m[12] * m[3] * m[9];

    inv.m[13] = m[0] * m[9] * m[14] -
      m[0] * m[10] * m[13] -
      m[8] * m[1] * m[14] +
      m[8] * m[2] * m[13] +
      m[12] * m[1] * m[10] -
      m[12] * m[2] * m[9];

    inv.m[2] = m[1] * m[6] * m[15] -
      m[1] * m[7] * m[14] -
      m[5] * m[2] * m[15] +
      m[5] * m[3] * m[14] +
      m[13] * m[2] * m[7] -
      m[13] * m[3] * m[6];

    inv.m[6] = -m[0] * m[6] * m[15] +
      m[0] * m[7] * m[14] +
      m[4] * m[2] * m[15] -
      m[4] * m[3] * m[14] -
      m[12] * m[2] * m[7] +
      m[12] * m[3] * m[6];

    inv.m[10] = m[0] * m[5] * m[15] -
      m[0] * m[7] * m[13] -
      m[4] * m[1] * m[15] +
      m[4] * m[3] * m[13] +
      m[12] * m[1] * m[7] -
      m[12] * m[3] * m[5];

    inv.m[14] = -m[0] * m[5] * m[14] +
      m[0] * m[6] * m[13] +
      m[4] * m[1] * m[14] -
      m[4] * m[2] * m[13] -
      m[12] * m[1] * m[6] +
      m[12] * m[2] * m[5];

    inv.m[3] = -m[1] * m[6] * m[11] +
      m[1] * m[7] * m[10] +
      m[5] * m[2] * m[11] -
      m[5] * m[3] * m[10] -
      m[9] * m[2] * m[7] +
      m[9] * m[3] * m[6];

    inv.m[7] = m[0] * m[6] * m[11] -
      m[0] * m[7] * m[10] -
      m[4] * m[2] * m[11] +
      m[4] * m[3] * m[10] +
      m[8] * m[2] * m[7] -
      m[8] * m[3] * m[6];

    inv.m[11] = -m[0] * m[5] * m[11] +
      m[0] * m[7] * m[9] +
      m[4] * m[1] * m[11] -
      m[4] * m[3] * m[9] -
      m[8] * m[1] * m[7] +
      m[8] * m[3] * m[5];

    inv.m[15] = m[0] * m[5] * m[10] -
      m[0] * m[6] * m[9] -
      m[4] * m[1] * m[10] +
      m[4] * m[2] * m[9] +
      m[8] * m[1] * m[6] -
      m[8] * m[2] * m[5];

    float det = m[0] * inv.m[0] + m[1] * inv.m[4] + m[2] * inv.m[8] + m[3] * inv.m[12];
    inv.dive(det);
    return inv;
    
    
    
  }
  public String toString(){
    return str(m[0])+" "+str(m[1])+" "+str(m[2])+" "+str(m[3])+"\n"
          +str(m[4])+" "+str(m[5])+" "+str(m[6])+" "+str(m[7])+"\n"
          +str(m[8])+" "+str(m[9])+" "+str(m[10])+" "+str(m[11])+"\n"
          +str(m[12])+" "+str(m[13])+" "+str(m[14])+" "+str(m[15]);
  }
}
class Mesh {
    int NUM_VBOS=3;
    ArrayList<Vector3> verts=new ArrayList<Vector3>();
    ArrayList<Vector3> uvs=new ArrayList<Vector3>();
    ArrayList<Vector3> normals=new ArrayList<Vector3>();
    ArrayList<Triangle> triangles=new ArrayList<Triangle>();
    ArrayList<Vector4> tangents=new ArrayList<Vector4>();


    Mesh(String fname) {
        String[] fin=loadStrings(fname);
        for (int i=0; i<fin.length; i+=1) {
            String line=fin[i];
            if (line.indexOf("# ")!=-1) {
                continue;
            } else if (line.indexOf("v ")!=-1) {
                String[] s=line.split(" ");
                verts.add(new Vector3(PApplet.parseFloat(s[1]), PApplet.parseFloat(s[2]), PApplet.parseFloat(s[3])));
            } else if (line.indexOf("vt ")!=-1) {
                String[] s=line.split(" ");
                uvs.add(new Vector3(PApplet.parseFloat(s[1]), PApplet.parseFloat(s[2]), 0));
            } else if (line.indexOf("vn ")!=-1) {
                String[] s=line.split(" ");
                normals.add(new Vector3(PApplet.parseFloat(s[1]), PApplet.parseFloat(s[2]), PApplet.parseFloat(s[3])));
            } else if (line.indexOf("c ")!=-1) {
                int a, b, c=0;
                if (line.charAt(2)=='*') {
                    int v_ix=verts.size();
                    a=v_ix-2;
                    b=v_ix-1;
                    c=v_ix;
                } else {
                    String[] s=line.split(" ");
                    a=PApplet.parseInt(s[1]);
                    b=PApplet.parseInt(s[2]);
                    c=PApplet.parseInt(s[3]);
                }
                Vector3 v1=verts.get(a-1);
                Vector3 v2=verts.get(b-1);
                Vector3 v3=verts.get(c-1);
            } else if (line.indexOf("f ")!=-1) {
                int num_slashes=0;
                int last_slash_ix=0;
                boolean double_slashes=false;
                StringBuilder sb=new StringBuilder(line);
                for (int j=0; j<line.length(); j+=1) {


                    if (sb.charAt(j)=='/') {
                        sb.setCharAt(j, ' ');
                        if (last_slash_ix==i-1) double_slashes=true;
                        last_slash_ix=i;
                        num_slashes++;
                    }
                }
                line=new String(sb);

                int a=0, b=0, c=0, d=0;
                int at=0, bt=0, ct=0, dt=0;
                boolean wild=line.charAt(2)=='*';
                boolean wild2=line.charAt(3)=='*';
                boolean isQuad=false;
                String[] s=line.split(" ");
                if (wild) {
                } else if (num_slashes==0) {
                    isQuad= s.length==5;
                    if (isQuad) {
                        a=PApplet.parseInt(s[1]);
                        b=PApplet.parseInt(s[2]);
                        c=PApplet.parseInt(s[3]);
                        d=PApplet.parseInt(s[4]);
                    } else {
                        a=PApplet.parseInt(s[1]);
                        b=PApplet.parseInt(s[2]);
                        c=PApplet.parseInt(s[3]);
                    }
                    at = a;
                    bt = b;
                    ct = c;
                    dt = d;
                } else if (num_slashes==3) {
                    a=PApplet.parseInt(s[1]);
                    at=PApplet.parseInt(s[2]);
                    b=PApplet.parseInt(s[3]);
                    bt=PApplet.parseInt(s[4]);
                    c=PApplet.parseInt(s[5]);
                    ct=PApplet.parseInt(s[6]);
                } else if (num_slashes==4) {
                    a=PApplet.parseInt(s[1]);
                    at=PApplet.parseInt(s[2]);
                    b=PApplet.parseInt(s[3]);
                    bt=PApplet.parseInt(s[4]);
                    c=PApplet.parseInt(s[5]);
                    ct=PApplet.parseInt(s[6]);
                    d=PApplet.parseInt(s[7]);
                    dt=PApplet.parseInt(s[8]);
                    isQuad=true;
                } else if (num_slashes==6) {
                    if (double_slashes) {
                        a=PApplet.parseInt(s[1]);
                        at=PApplet.parseInt(s[1]);
                        b=PApplet.parseInt(s[3]);
                        bt=PApplet.parseInt(s[3]);
                        c=PApplet.parseInt(s[5]);
                        ct=PApplet.parseInt(s[5]);
                    } else {
                        a=PApplet.parseInt(s[1]);
                        at=PApplet.parseInt(s[2]);
                        b=PApplet.parseInt(s[4]);
                        bt=PApplet.parseInt(s[5]);
                        c=PApplet.parseInt(s[7]);
                        ct=PApplet.parseInt(s[8]);
                    }
                } else if (num_slashes==8) {
                    isQuad=true;
                    if (double_slashes) {
                        a=PApplet.parseInt(s[1]);
                        at=PApplet.parseInt(s[1]);
                        b=PApplet.parseInt(s[3]);
                        bt=PApplet.parseInt(s[3]);
                        c=PApplet.parseInt(s[5]);
                        ct=PApplet.parseInt(s[5]);
                        d=PApplet.parseInt(s[7]);
                        dt=PApplet.parseInt(s[7]);
                    } else {
                        a=PApplet.parseInt(s[1]);
                        at=PApplet.parseInt(s[2]);
                        b=PApplet.parseInt(s[4]);
                        bt=PApplet.parseInt(s[5]);
                        c=PApplet.parseInt(s[7]);
                        ct=PApplet.parseInt(s[8]);
                        d=PApplet.parseInt(s[10]);
                        dt=PApplet.parseInt(s[11]);
                    }
                } else {
                    continue;
                }


                addFace(a, at, b, bt, c, ct);
                if (isQuad) {
                    addFace(a, at, c, ct, d, dt);
                }
            }
        }
        if(normals.size()==0)calcNormal();
        //calcTangent();
    }

    public void calcTangent() {
        Vector3[] tangent=new Vector3[verts.size()];
        Vector3[] bitangent=new Vector3[verts.size()];
        for (int i=0; i<tangent.length; i+=1) {
            tangent[i]=new Vector3();
            bitangent[i]=new Vector3();
        }
        for (int i=0; i<triangles.size(); i+=1) {
            int i0 = triangles.get(i).triangle[0];
            int i1 = triangles.get(i).triangle[1];
            int i2 = triangles.get(i).triangle[2];
            Vector3 p0 = verts.get(i0);
            Vector3 p1 = verts.get(i1);
            Vector3 p2 = verts.get(i2);
            Vector3 w0 = uvs.get(i0);
            Vector3 w1 = uvs.get(i1);
            Vector3 w2 = uvs.get(i2);
            Vector3 e1=p1.sub(p0);
            Vector3 e2=p2.sub(p0);
            float x1=w1.x-w0.x;
            float x2=w2.x-w0.x;
            float y1=w1.y-w0.y;
            float y2=w2.y-w0.y;

            float r=1.0f/(x1*y2-x2*y1);
            Vector3 t=((e1.mult(y2)).sub(e2.mult(y1))).mult(r);
            Vector3 b=((e2.mult(x1)).sub(e1.mult(x2))).mult(r);
            tangent[i0]=tangent[i0].add(t);
            tangent[i1]=tangent[i1].add(t);
            tangent[i2]=tangent[i2].add(t);

            bitangent[i0]=bitangent[i0].add(b);
            bitangent[i1]=bitangent[i1].add(b);
            bitangent[i2]=bitangent[i2].add(b);
        }

        for (int i=0; i<verts.size(); i+=1) {
            Vector3 t=tangent[i];
            Vector3 b=bitangent[i];
            Vector3 n=normals.get(i);
            Vector4 tan=new Vector4((t.sub(n.mult(Vector3.dot(n, t)))).unit_vector(), 0);
            tan.w=(Vector3.dot(Vector3.cross(n, t), b)<0.0f)?-1.0f:1.0f;
            tangents.add(tan);
        }
    }

    public void calcNormal() {
        Vector3[] normal = new Vector3[verts.size()];
        for (int i=0; i<normal.length; i+=1) {
            normal[i] = new Vector3();
        }
        for (int i=0; i<triangles.size(); i+=1) {
            for (int j=0; j<3; j+=1) {
                normal[triangles.get(i).triangle[j]].plus(triangles.get(i).normal[j]);
            }
        }

        for (int i=0; i<normal.length; i+=1) {
            normals.add(normal[i].unit_vector());
        }
        for (int i=0; i<triangles.size(); i+=1) {
            for (int j=0; j<3; j+=1) {
                triangles.get(i).normal[j] = normals.get(triangles.get(i).triangle[j]);
            }
        }
    }

    public void Draw() {
    }
    public void debudDraw() {
    }


    public void addFace(int a, int at, int b, int bt, int c, int ct) {
        a-=1;
        b-=1;
        c-=1;
        at-=1;
        bt-=1;
        ct-=1;
        int[] v_ix={a, b, c};
        int[] uv_ix={at, bt, ct};
        Vector3 v1=verts.get(a);
        Vector3 v2=verts.get(b);
        Vector3 v3=verts.get(c);
        Vector3[] vs={v1, v2, v3};
        Vector3[] normal=new Vector3[3];
        if (normals.size()==0) {
            for (int i=0; i<3; i+=1) {
                Vector3 n=Vector3.cross(Vector3.sub(vs[(i+1)%3], vs[i]), Vector3.sub(vs[(i+2)%3], vs[i])).unit_vector();
                normal[i]=n;
            }
        }else{
            normal[0] = (a >= 0 && a < normals.size()) ? normals.get(a) : new Vector3(0, 0, 0);
            normal[1] = (b >= 0 && b < normals.size()) ? normals.get(b) : new Vector3(0, 0, 0);
            normal[2] = (c >= 0 && c < normals.size()) ? normals.get(c) : new Vector3(0, 0, 0);
        }
        if (uvs.size()>=1) {
            Vector3[] us={uvs.get(at), uvs.get(bt), uvs.get(ct)};
            int[] triangle={a, b, c};
            triangles.add(new Triangle(vs, us, normal, triangle));
        } else {
            Vector3[] us={null, null, null};
            int[] triangle={a, b, c};
            triangles.add(new Triangle(vs, us, normal, triangle));
        }
    }


    @Override
        public String toString() {
        int c=1;
        String s=new String();
        for (Triangle t : triangles) {
            s+=t.toString();
        }
        return s;
    }
}

class Triangle {
    Vector3[] verts;
    Vector3[] uvs;
    Vector3[] normal;
    int[] triangle;
    Triangle(Vector3[] verts, Vector3[] uvs, Vector3[] normal, int[] triangle) {
        this.verts=verts;
        this.uvs=uvs;
        this.normal=normal;
        this.triangle=triangle;
    }

    @Override
        public String toString() {
        String s="Vertices: \n";
        for (Vector3 v : verts) {
            s+=v.toString()+"\n";
        }
        s+="Uvs: \n";
        for (Vector3 v : uvs) {
            s+=v.toString()+"\n";
        }
        return s;
    }
}
public class Renderer {
    private Box box;
    private ArrayList<GameObject> gameObject;

    public Renderer() {
        box = new Box(renderer_size.x, renderer_size.y, renderer_size.z - renderer_size.x,
                renderer_size.w - renderer_size.y);
        box.setBoxColor(250);
        gameObject = new ArrayList<GameObject>();
    }

    public void run() {
        box.show();
        gameObject.forEach(GameObject::Draw);
        image(renderBuffer, renderer_size.x, renderer_size.y, renderer_size.z - renderer_size.x,
                renderer_size.w - renderer_size.y);
        if (debug)
            gameObject.forEach(GameObject::debugDraw);
    }

    public void addGameObject(GameObject go) {
        gameObject.add(go);
        engine.hierarchy.addButton(go);
    }

    public boolean checkInBox(Vector3 v) {
        return box.checkInSide(v);
    }

    public void popShape() {
        if (gameObject.size() <= 0)
            return;
        gameObject.remove(gameObject.size() - 1);
    }

    public void clear() {
        gameObject.clear();
    }
}

public class Hierarchy {
    private Box box;
    ArrayList<GameObject> gameObject;
    ArrayList<HierarchyButton> buttons;

    public Hierarchy(ArrayList<GameObject> go) {
        box = new Box(500 + 40, 50, 200, height - 100);
        box.setBoxColor(250);
        gameObject = go;
        buttons = new ArrayList<HierarchyButton>();
    }

    public void addButton(GameObject go) {
        float y = buttons.size() * 30;
        HierarchyButton hb = new HierarchyButton(box.pos.x, box.pos.y + y, 200, 30);
        hb.name = go.getGameObjectName();
        hb.setBoxAndClickColor(color(250), color(150));
        hb.gameObject = go;
        buttons.add(hb);
    }

    public void run() {
        textAlign(LEFT, CENTER);
        textSize(18);
        fill(0);
        text("Hierarchy", box.pos.x, box.pos.y - 10);
        box.show();

        for (HierarchyButton hb : buttons) {
            hb.run(() -> {
                engine.inspector.setGameObject(hb.gameObject);
            });
        }
    }
}

public class Inspector {
    private Box box;
    GameObject gameObject;
    Slider[] position_slider = new Slider[3];
    Slider[] rotation_slider = new Slider[3];
    Slider[] scale_slider = new Slider[3];

    Slider[] object_color_slider = new Slider[3];

    Slider[] light_color_slider = new Slider[3];
    Slider light_intensity_slider;
    
    String inspectName = "xyz";
    MaterialButton materialButton;

    public Inspector() {

        box = new Box(740 + 20, 50, 200, height - 100);
        box.setBoxColor(250);
    }

    public void setGameObject(GameObject go) {
        gameObject = go;
        for (int i = 0; i < position_slider.length; i++) {
            position_slider[i] = new Slider(box.pos.add(new Vector3(40, 30 + i * 20, 0)),
                    new Vector3(box.pos.x + 40, box.pos.x + 150, 0), new Vector3(-50, 50, 0), true);
        }
        position_slider[0].setValue(gameObject.transform.position.x);
        position_slider[1].setValue(gameObject.transform.position.y);
        position_slider[2].setValue(gameObject.transform.position.z);

        for (int i = 0; i < rotation_slider.length; i++) {
            rotation_slider[i] = new Slider(box.pos.add(new Vector3(40, 30 + i * 20 + 100, 0)),
                    new Vector3(box.pos.x + 40, box.pos.x + 150, 0), new Vector3(0, 6.28f, 0), true);
        }
        rotation_slider[0].setValue(gameObject.transform.rotation.x);
        rotation_slider[1].setValue(gameObject.transform.rotation.y);
        rotation_slider[2].setValue(gameObject.transform.rotation.z);

        for (int i = 0; i < scale_slider.length; i++) {
            scale_slider[i] = new Slider(box.pos.add(new Vector3(40, 30 + i * 20 + 200, 0)),
                    new Vector3(box.pos.x + 40, box.pos.x + 150, 0), new Vector3(0.1f, 3, 0), true);
        }
        scale_slider[0].setValue(gameObject.transform.scale.x);
        scale_slider[1].setValue(gameObject.transform.scale.y);
        scale_slider[2].setValue(gameObject.transform.scale.z);

        for (int i = 0; i < object_color_slider.length; i++) {
            object_color_slider[i] = new Slider(box.pos.add(new Vector3(40, 30 + i * 20 + 300, 0)),
                    new Vector3(box.pos.x + 40, box.pos.x + 150, 0), new Vector3(0, 1, 0), true);
        }
        object_color_slider[0].setValue(basic_light.light_color.x);
        object_color_slider[1].setValue(basic_light.light_color.y);
        object_color_slider[2].setValue(basic_light.light_color.z);

        for (int i = 0; i < scale_slider.length; i++) {
            light_color_slider[i] = new Slider(box.pos.add(new Vector3(40, 30 + i * 20 + 300, 0)),
                    new Vector3(box.pos.x + 40, box.pos.x + 150, 0), new Vector3(0, 1, 0), true);
        }
        light_color_slider[0].setValue(basic_light.light_color.x);
        light_color_slider[1].setValue(basic_light.light_color.y);
        light_color_slider[2].setValue(basic_light.light_color.z);
        
        light_intensity_slider = new Slider(box.pos.add(new Vector3(40, 30 + 20 + 400, 0)),
                    new Vector3(box.pos.x + 40, box.pos.x + 150, 0), new Vector3(0, 5, 0), true);
        light_intensity_slider.setValue(basic_light.intensity);

        materialButton = new MaterialButton(box.pos.add(new Vector3(40, 30 + 3 * 20 + 350, 0)),
                new Vector3(120, 40, 0));
        materialButton.setBoxAndClickColor(color(150), color(100));
    }

    public void run() {
        textAlign(LEFT, CENTER);
        textSize(18);
        fill(0);
        text("Inspector", box.pos.x, box.pos.y - 10);
        box.show();
        if (gameObject != null) {
            textAlign(LEFT, CENTER);
            textSize(15);
            fill(0);
            text("position", box.pos.x, box.pos.y + 15);
            for (int i = 0; i < position_slider.length; i++) {
                textAlign(LEFT, CENTER);
                textSize(15);
                fill(0);
                text(inspectName.charAt(i), box.pos.x, position_slider[i].pos.y + 5);
                text(position_slider[i].value(), box.pos.x + 170, position_slider[i].pos.y + 5);
                position_slider[i].show();
                position_slider[i].click();
            }
            gameObject.transform.position = new Vector3(position_slider[0].value(), position_slider[1].value(),
                    position_slider[2].value());

            textAlign(LEFT, CENTER);
            textSize(15);
            fill(0);
            text("rotation", box.pos.x, box.pos.y + 15 + 100);
            for (int i = 0; i < rotation_slider.length; i++) {
                textAlign(LEFT, CENTER);
                textSize(15);
                fill(0);
                text(inspectName.charAt(i), box.pos.x, rotation_slider[i].pos.y + 5);
                text(rotation_slider[i].value(), box.pos.x + 170, rotation_slider[i].pos.y + 5);
                rotation_slider[i].show();
                rotation_slider[i].click();
            }
            gameObject.transform.rotation = new Vector3(rotation_slider[0].value(), rotation_slider[1].value(),
                    rotation_slider[2].value());

            textAlign(LEFT, CENTER);
            textSize(15);
            fill(0);
            text("scale", box.pos.x, box.pos.y + 15 + 200);
            for (int i = 0; i < scale_slider.length; i++) {
                textAlign(LEFT, CENTER);
                textSize(15);
                fill(0);
                text(inspectName.charAt(i), box.pos.x, scale_slider[i].pos.y + 5);
                text(scale_slider[i].value(), box.pos.x + 170, scale_slider[i].pos.y + 5);
                scale_slider[i].show();
                scale_slider[i].click();
            }
            gameObject.transform.scale = new Vector3(scale_slider[0].value(), scale_slider[1].value(),
                    scale_slider[2].value());
            if (gameObject.getClass() == GameObject.class) {

                textAlign(LEFT, CENTER);
                textSize(15);
                fill(0);
                text("Color", box.pos.x, box.pos.y + 15 + 300);
                String rgb = "rgb";
                for (int i = 0; i < object_color_slider.length; i++) {
                    textAlign(LEFT, CENTER);
                    textSize(15);
                    fill(0);
                    text(rgb.charAt(i), box.pos.x, light_color_slider[i].pos.y + 5);
                    text(object_color_slider[i].value(), box.pos.x + 170, object_color_slider[i].pos.y + 5);
                    object_color_slider[i].show();
                    object_color_slider[i].click();
                }
                gameObject.material.albedo = new Vector3(object_color_slider[0].value(), object_color_slider[1].value(),
                        object_color_slider[2].value());

                materialButton.run(() -> {
                    switch (gameObject.me) {
                        case DM:
                            gameObject.me = MaterialEnum.FM;
                            gameObject.material = new FlatMaterial();
                            materialButton.name = "FlatMaterial";
                            break;
                        case FM:
                            gameObject.me = MaterialEnum.GM;
                            gameObject.material = new GouraudMaterial();
                            materialButton.name = "GouraudMaterial";
                            break;
                        case GM:
                            gameObject.me = MaterialEnum.PM;
                            gameObject.material = new PhongMaterial();
                            materialButton.name = "PhongMaterial";
                            break;
                        case PM:
                            gameObject.me = MaterialEnum.DM;
                            gameObject.material = new DepthMaterial();
                            materialButton.name = "DepthMaterial";
                            break;
                    }
                });
            } else if (gameObject.getClass() == Light.class) {
                textAlign(LEFT, CENTER);
                textSize(15);
                fill(0);
                text("Light", box.pos.x, box.pos.y + 15 + 300);
                String rgb = "rgb";
                for (int i = 0; i < light_color_slider.length; i++) {
                    textAlign(LEFT, CENTER);
                    textSize(15);
                    fill(0);
                    text(rgb.charAt(i), box.pos.x, light_color_slider[i].pos.y + 5);
                    text(light_color_slider[i].value(), box.pos.x + 170, light_color_slider[i].pos.y + 5);
                    light_color_slider[i].show();
                    light_color_slider[i].click();
                }
                basic_light.light_color = new Vector3(light_color_slider[0].value(), light_color_slider[1].value(),
                        light_color_slider[2].value());
                
                textAlign(LEFT, CENTER);
                textSize(15);
                fill(0);
                text("Intensity", box.pos.x, box.pos.y + 15 + 400);  
                text("I", box.pos.x, light_intensity_slider.pos.y + 5);
                text(light_intensity_slider.value(), box.pos.x + 170, light_intensity_slider.pos.y + 5);
                light_intensity_slider.show();
                light_intensity_slider.click();
                basic_light.intensity = light_intensity_slider.value();
            }
        }
    }
}
public class Shader {
    VertexShader vertex;
    FragmentShader fragment;

    public Shader(VertexShader v, FragmentShader f) {
        vertex = v;
        fragment = f;
    }
}

public abstract class VertexShader {
    public abstract Vector4[][] main(Object[] attribute, Object[] uniform);
}

public abstract class FragmentShader {
    public abstract Vector4 main(Object[] varying);
}

public class DepthVertexShader extends VertexShader {
    public Vector4[][] main(Object[] attribute, Object[] uniform) {
        Vector3[] aVertexPosition = (Vector3[]) attribute[0];
        Matrix4 MVP = (Matrix4) uniform[0];
        Vector4[] gl_Position = new Vector4[3];
        for (int i = 0; i < gl_Position.length; i++) {
            gl_Position[i] = MVP.mult(aVertexPosition[i].getVector4(1.0f));
        }

        Vector4[][] result = { gl_Position };

        return result;
    }
}

public class DepthFragmentShader extends FragmentShader {
    public Vector4 main(Object[] varying) {
        Vector3 position = (Vector3) varying[0];

        return new Vector4(position.z, position.z, position.z, 1.0f);
    }
}
class Slider extends Button {
    boolean vertical = false;
    Vector3 start_end_point;
    Vector3 min_max_value;

    Slider(Vector3 p, Vector3 sep, Vector3 mmv, boolean v) {
        super(p, null);
        vertical = v;
        Vector3 s = vertical ? new Vector3(20, 10, 0) : new Vector3(10, 20, 0);
        start_end_point = sep;
        min_max_value = mmv;
        size = s;
        setBoxAndClickColor(color(100), color(70));
    }

    @Override
    public void show() {
        if (vertical) {
            fill(150);
            rect(start_end_point.x, pos.y, start_end_point.y - start_end_point.x, 10);
        } else {
            fill(150);
            rect(pos.x, start_end_point.x, 10, start_end_point.y - start_end_point.x);
        }
        super.show();

    }

    public void click() {

        if (!checkInSide() && !press)
            return;
        if (mousePressed) {
            press = true;
            if (vertical)
                pos = new Vector3(max(start_end_point.x, min(start_end_point.y, mouseX)), pos.y, 0);
            else
                pos = new Vector3(pos.x, max(start_end_point.x, min(start_end_point.y, mouseY)), 0);
        } else {
            press = false;
            once = false;
        }
    }

    public float value() {
        return map(vertical ? pos.x : pos.y, start_end_point.x, start_end_point.y, min_max_value.x, min_max_value.y);
    }

    public void setValue(float v) {
        if (vertical) {
            pos.x = map(v, min_max_value.x, min_max_value.y, start_end_point.x, start_end_point.y);
        } else {
            pos.y = map(v, min_max_value.x, min_max_value.y, start_end_point.x, start_end_point.y);
        }
    }

}
public class Transform {
    Vector3 position;
    Vector3 rotation;
    Vector3 scale;

    public Transform() {
        position = new Vector3();
        rotation = new Vector3();
        scale = new Vector3(1, 1, 1);
    }

    public Transform(Vector3 pos, Vector3 rot, Vector3 scl) {
        position = pos;
        rotation = rot;
        scale = scl;
    }
}
static final public class Vector3 {
    private float x;
    private float y;
    private float z;

    Vector3() {
        x=0;
        y=0;
        z=0;
    }
    Vector3(float _a) {
        x=_a;
        y=_a;
        z=_a;
    }
    Vector3(float _x, float _y, float _z) {
        x=_x;
        y=_y;
        z=_z;
    }
    public float x() {
        return x;
    }
    public float y() {
        return y;
    }
    public float z() {
        return z;
    }

    public float xyz(int i) {
        if (i==0) return x;
        else if (i==1) return y;
        else return z;
    }
    public static Vector3 Zero() {
        return new Vector3(0);
    }
    public static Vector3 Ones() {
        return new Vector3(1);
    }
    public static Vector3 UnitX() {
        return new Vector3(1, 0, 0);
    }
    public static Vector3 UnitY() {
        return new Vector3(0, 1, 0);
    }
    public static Vector3 UnitZ() {
        return new Vector3(0, 0, 1);
    }

    public void set(float _x, float _y, float _z) {
        x = _x;
        y = _y;
        z = _z;
    }
    public void setZero() {
        x = 0.0f;
        y = 0.0f;
        z = 0.0f;
    }
    public void setOnes() {
        x = 1.0f;
        y = 1.0f;
        z = 1.0f;
    }
    public void setUnitX() {
        x = 1.0f;
        y = 0.0f;
        z = 0.0f;
    }
    public void setUnitY() {
        x = 0.0f;
        y = 1.0f;
        z = 0.0f;
    }
    public void setUnitZ() {
        x = 0.0f;
        y = 0.0f;
        z = 1.0f;
    }


    public static Vector3 add(Vector3 a, Vector3 b) {
        Vector3 result=new Vector3();
        result.x=a.x+b.x;
        result.y=a.y+b.y;
        result.z=a.z+b.z;
        return result;
    }
    public static Vector3 sub(Vector3 a, Vector3 b) {
        Vector3 result=new Vector3();
        result.x=a.x-b.x;
        result.y=a.y-b.y;
        result.z=a.z-b.z;
        return result;
    }
    public static Vector3 mult(float n, Vector3 a) {
        Vector3 result=new Vector3();
        result.x=n*a.x;
        result.y=n*a.y;
        result.z=n*a.z;
        return result;
    }
    public Vector3 mult(float n) {
        Vector3 result=new Vector3();
        result.x=n*x;
        result.y=n*y;
        result.z=n*z;
        return result;
    }


    public void product(float n) {

        x*=n;
        y*=n;
        z*=n;
    }

    public Vector3 dive(float n) {
        Vector3 result=new Vector3();
        result.x=x/n;
        result.y=y/n;
        result.z=z/n;
        return result;
    }
    public float minComponent(){
        return min(x,min(y,z));
    }
    
    public float maxComponent(){
        return max(x,max(y,z));
    }
    
    public static Vector3 cross(Vector3 a, Vector3 b) {
        Vector3 result=new Vector3();
        result.x=a.y*b.z-a.z*b.y;
        result.y=a.z*b.x-a.x*b.z;
        result.z=a.x*b.y-a.y*b.x;
        return result;
    }

    public static float dot(Vector3 a, Vector3 b) {
        return a.x*b.x+a.y*b.y+a.z*b.z;
    }
    public float norm() {
        return sqrt(x*x+y*y+z*z);
    }

    public void print() {
        println("x: "+x+" y: "+y+" z: "+z);
    }
    public Vector3 unit_vector() {
        return Vector3.mult(1/this.norm(), this);
    }
    public void normalize() {
        float a=1/this.norm();
        this.product(a);
    }

    public static Vector3 unit_vector(Vector3 v) {
        return Vector3.mult(1/v.norm(), v);
    }
    public Vector3 sub(Vector3 b) {
        Vector3 result=new Vector3();
        result.x=x-b.x;
        result.y=y-b.y;
        result.z=z-b.z;
        return result;
    }
    public Vector3 add(Vector3 b) {
        Vector3 result=new Vector3();
        result.x=x+b.x;
        result.y=y+b.y;
        result.z=z+b.z;
        return result;
    }

    public void minus(Vector3 b) {

        x-=b.x;
        y-=b.y;
        z-=b.z;
    }
    public void plus(Vector3 b) {

        x+=b.x;
        y+=b.y;
        z+=b.z;
    }

    public float length_squared() {
        return x*x+y*y+z*z;
    }
    public float length() {
        return sqrt(this.length_squared());
    }

    public boolean near_zero() {
        float s=1e-8f;
        return (abs(x)<s)&&abs(y)<s&&abs(z)<s;
    }
    public Vector3 product(Vector3 v) {
        Vector3 result=new Vector3();
        result.x=x*v.x;
        result.y=y*v.y;
        result.z=z*v.z;
        return result;
    }



    public Vector3 inv() {
        return new Vector3(1/x, 1/y, 1/z);
    }
    public float magSq() {
        return x*x+y*y+z*z;
    }
    public void clipMag(float m) {
        float r=magSq()/(m*m);
        if (r>1) {
            float sr=sqrt(r);
            x/=sr;
            y/=sr;
            z/=sr;
        }
    }

    public Vector3 copy() {
        return new Vector3(x, y, z);
    }
    
    public void copy(Vector3 b) {
        x=b.x;
        y=b.y;
        z=b.z;
    }
     public Vector4 getVector4() {
        return new Vector4(this, 1);
    }
    public Vector4 getVector4(float b) {
        return new Vector4(this, b);
    }

    @Override
        public String toString() {
        return "x : "+x+" y : "+y+" z : "+z;
    }
}


static public class Vector4 {
    float x, y, z, w;
    Vector4() {
    }
    Vector4(Vector3 xyz, float w) {
        this.x=xyz.x;
        this.y=xyz.y;
        this.z=xyz.z;
        this.w=w;
    }
    Vector4(float x, float y, float z, float w) {
        this.x=x;
        this.y=y;
        this.z=z;
        this.w=w;
    }
    Vector4(float x) {
        this.x=x;
        this.y=x;
        this.z=x;
        this.w=x;
    }

    public Vector3 xyz() {
        return new Vector3(x, y, z);
    }
    public Vector3 xyzNormalize() {
        return xyz().unit_vector();
    }
    public Vector3 homogenized() {
        //if (w<0) return new Vector3(-x/w, -y/w, -z/w);
        return new Vector3(x/w, y/w, z/w);
    }

    public Vector4 reverseW() {
        return new Vector4(x, y, z, -abs(w));
    }

    public Vector4 add(Vector4 v) {
        return new Vector4(x+v.x, y+v.y, z+v.z, w);
    }

    public Vector4 mult(float b) {
        return new Vector4(x*b, y*b, z*b, w);
    }
    public Vector4 mult(Matrix4 m) {
        return new Vector4(
            m.m[0]*x  + m.m[1]*y  + m.m[2]*z  + m.m[3]*w,
            m.m[4]*x  + m.m[5]*y  + m.m[6]*z  + m.m[7]*w,
            m.m[8]*x  + m.m[9]*y  + m.m[10]*z + m.m[11]*w,
            m.m[12]*x + m.m[13]*y + m.m[14]*z + m.m[15]*w
            );
    }

    public void multiply(float b) {
        x*=b;
        y*=b;
        z*=b;
    }


    public Vector4 div(float b) {
        return new Vector4(x/b, y/b, z/b, w);
    }
    public void dive(float b) {
        x/=b;
        y/=b;
        z/=b;
        w/=b;
    }
    public float dot(Vector4 b) {
        return x*b.x + y*b.y + z*b.z;
    }

    public float dot(Vector3 b) {
        return x*b.x + y*b.y + z*b.z;
    }

    @Override
        public String toString() {
        return "x : "+x+" y : "+y+" z : "+z + " w : " + w;
    }
}
public class Engine {
    Renderer renderer;
    Inspector inspector;
    Hierarchy hierarchy;

    Vector3[] boundary = { new Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0), new Vector3(1, -1, 0) };

    ArrayList<ShapeButton> shapeButton = new ArrayList<ShapeButton>();
    ShapeButton selctFileButton;
    ShapeButton DegubButton;

    public Engine(){
        renderer = new Renderer();
        inspector = new Inspector();
        hierarchy = new Hierarchy(renderer.gameObject);
        main_camera.setSize(PApplet.parseInt(renderer_size.z - renderer_size.x) , PApplet.parseInt(renderer_size.w - renderer_size.y) , GH_NEAR_MAX , GH_FAR);
        main_camera.setPositionOrientation();
        basic_light = new Light();        
        initButton();        
        
    }

    public void initButton() {
        selctFileButton = new ShapeButton(20, 10, 30, 30) {

        };

        selctFileButton.setBoxAndClickColor(color(250), color(150));
        selctFileButton.setImage(loadImage("cube.png"));
        shapeButton.add(selctFileButton);

        DegubButton = new ShapeButton(60, 10, 30, 30);
        DegubButton.setBoxAndClickColor(color(250), color(150));
        DegubButton.setImage(loadImage("debug.png"));

    }

    public void run() {
        setDepthBuffer();
        renderer.run();
        inspector.run();
        hierarchy.run();

        for (ShapeButton sb : shapeButton) {
            sb.run(() -> {
                String path = selectFile();
                // try{
                renderer.addGameObject(new GameObject(path));
                // }catch(Exception ex){
                // println("Occure some error. Please change another files");
                // }
            });
        }

        DegubButton.run(() -> {
            debug = !debug;
        });
        main_camera.setPositionOrientation();

    }

}
public void CGLine(float x1, float y1, float x2, float y2) {
    stroke(0);
    line(x1, y1, x2, y2);
}

public boolean outOfBoundary(float x, float y) {
    if (x < 0 || x >= width || y < 0 || y >= height)
        return true;
    return false;
}

public void drawPoint(float x, float y, int c) {
    int index = (int) y * width + (int) x;
    if (outOfBoundary(x, y))
        return;
    pixels[index] = c;
}

public boolean isPointOnLineSegment(Vector3 p1, Vector3 p2, Vector3 p3) {
    if(Math.abs((Vector3.cross(p2.sub(p1), p3.sub(p1))).length()) > 1e-6f) return false;
    return (Math.min(p1.x, p2.x) <= p3.x && p3.x <= Math.max(p1.x, p2.x) &&
            Math.min(p1.y, p2.y) <= p3.y && p3.y <= Math.max(p1.y, p2.y));
}

public boolean pnpoly(float x, float y, Vector3[] vertexes) {
    // TODO HW2
    // You need to check the coordinate p(x,v) if inside the vertexes. 
    int intersections = 0;
    Vector3 tmp = new Vector3(x, y, 0);
    for(int i = 0; i < vertexes.length; ++i){
        Vector3 p1 = vertexes[i];
        Vector3 p2 = vertexes[(i + 1) % vertexes.length];
        // 在線段上
        boolean onEdge = isPointOnLineSegment(vertexes[i], vertexes[(i + 1) % vertexes.length], tmp);
        if(onEdge){
            return true;
        }
        // 是否可以穿透該條線
        if ((p1.y > tmp.y) != (p2.y > tmp.y)) {
            // 射線的交點
            float xIntersection = p1.x + (tmp.y - p1.y) * (p2.x - p1.x) / (p2.y - p1.y);
            if (tmp.x < xIntersection) {
                intersections++;
            }
        }
    }
    return (intersections % 2 == 1);
}

public Vector3[] findBoundBox(Vector3[] v) {
    Vector3 recordminV = new Vector3(1.0f / 0.0f);
    Vector3 recordmaxV = new Vector3(-1.0f / 0.0f);
    // TODO HW2
    // You need to find the bounding box of the vertexes v.

    float minX = Float.MAX_VALUE, minY = Float.MAX_VALUE;
    float maxX = -Float.MAX_VALUE, maxY = -Float.MAX_VALUE;

    for (Vector3 vertex : v) {
        minX = Math.min(minX, vertex.x);
        minY = Math.min(minY, vertex.y);
        maxX = Math.max(maxX, vertex.x);
        maxY = Math.max(maxY, vertex.y);
    }

    return new Vector3[] { new Vector3(minX, minY, 0), new Vector3(maxX, maxY, 0) };
}

public Vector3[] Sutherland_Hodgman_algorithm(Vector3[] points, Vector3[] boundary) {
    ArrayList<Vector3> input = new ArrayList<Vector3>();
    ArrayList<Vector3> output = new ArrayList<Vector3>();
    for (int i = 0; i < points.length; i += 1) {
        input.add(points[i]);
    }

    // TODO HW2
    // You need to implement the Sutherland Hodgman Algorithm in this section.
    // The function you pass 2 parameter. One is the vertexes of the shape "points".
    // And the other is the vertexes of the "boundary".
    // The output is the vertexes of the polygon.
   for (int i = 0; i < boundary.length && input.size() != 0; ++i) {
        Vector3 boundary1 = boundary[i];
        Vector3 boundary2 = boundary[(i + 1) % boundary.length];
        // 線段是逆時針
        Vector3 AB = boundary2.sub(boundary1);
        Vector3 AC = (input.get(input.size() - 1)).sub(boundary1);
        boolean preInside =  ((Vector3.cross(AB, AC)).length() >= 0);
        for (int j = 0; j < input.size(); ++j) {
            Vector3 AD = (input.get(j)).sub(boundary1);    
            boolean curInside = ((Vector3.cross(AB, AD)).length() >= 0);
            Vector3 prePoint = input.get((j - 1 + input.size()) % input.size());
            Vector3 nowPoint = input.get(j);
            
            float denom = (boundary1.x - boundary2.x) * (prePoint.y - nowPoint.y) - (boundary1.y - boundary2.y) * (prePoint.x - nowPoint.x);
            float intersectX = ((boundary1.x * boundary2.y - boundary1.y * boundary2.x) * (prePoint.x - nowPoint.x) - (boundary1.x - boundary2.x) * (prePoint.x * nowPoint.y - prePoint.y * nowPoint.x)) / denom;
            float intersectY = ((boundary1.x * boundary2.y - boundary1.y * boundary2.x) * (prePoint.y - nowPoint.y) - (boundary1.y - boundary2.y) * (prePoint.x * nowPoint.y - prePoint.y * nowPoint.x)) / denom;

            Vector3 crossDot = new Vector3(intersectX, intersectY, 0);
            
            if (curInside) {
                // 當前點在邊界內
                if (!preInside) {
                    output.add(crossDot); // 加入交點
                }
                output.add(input.get(j)); // 加入當前點
            } else {
                if (preInside) {
                    output.add(crossDot); // 加入交點
                }
            }
            preInside = curInside;
        }
        input.clear();  // 清空現有內容
        input.addAll(output);  // 直接把 output 放入 input，減少複製操作
        output.clear();
    }

    Vector3[] result = new Vector3[output.size()];
    for (int i = 0; i < result.length; i += 1) {
        result[i] = output.get(i);
    }
    return result;
}

public float getDepth(float x, float y, Vector3[] vertex) {
    // TODO HW3
    // You need to calculate the depth (z) in the triangle (vertex) based on the
    // positions x and y. and return the z value;
    Vector3 AB = vertex[1].sub(vertex[0]);
    Vector3 AC = vertex[2].sub(vertex[0]);
    Vector3 n = Vector3.cross(AB, AC);
    if(n.z < 1e-6f) return Float.MAX_VALUE;
    float d = -1 * Vector3.dot(n, vertex[0]);
    return -(n.x * x + n.y * y + d) / n.z;
}

public float[] barycentric(Vector3 P, Vector4[] verts) {

    Vector3 A = verts[0].homogenized();
    Vector3 B = verts[1].homogenized();
    Vector3 C = verts[2].homogenized();

    Vector4 AW = verts[0];
    Vector4 BW = verts[1];
    Vector4 CW = verts[2];

    // TODO HW4
    // Calculate the barycentric coordinates of point P in the triangle verts using
    // the barycentric coordinate system.
    // Please notice that you should use Perspective-Correct Interpolation otherwise
    // you will get wrong answer.

    //未校正過的
    Vector3 v0 = B.sub(A);
    Vector3 v1 = C.sub(A);
    Vector3 v2 = P.sub(A);
    float d00 = Vector3.dot(v0, v0);
    float d01 = Vector3.dot(v0, v1);
    float d11 = Vector3.dot(v1, v1);
    float d20 = Vector3.dot(v2, v0);
    float d21 = Vector3.dot(v2, v1);
    float denom = d00 * d11 - d01 * d01;
    float v = (d11 * d20 - d01 * d21) / denom;
    float w = (d00 * d21 - d01 * d20) / denom;
    float u = 1.0f - v - w;

    // 透視校正
    u = u / AW.w;
    v = v / BW.w;
    w = w / CW.w;
    float sum = u + v + w; // Osum = 1 
    u /= sum;
    v /= sum;
    w /= sum;
    float[] result = {u, v, w};
    return result;
}

public Vector3 interpolation(float[] abg, Vector3[] v) {
    return v[0].mult(abg[0]).add(v[1].mult(abg[1])).add(v[2].mult(abg[2]));
}

public Vector4 interpolation(float[] abg, Vector4[] v) {
    return v[0].mult(abg[0]).add(v[1].mult(abg[1])).add(v[2].mult(abg[2]));
}

public float interpolation(float[] abg, float[] v) {
    return v[0] * abg[0] + v[1] * abg[1] + v[2] * abg[2];
}


  public void settings() { size(1000, 600); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "HW4" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
